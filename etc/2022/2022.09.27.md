# 2022.09.27
#etc/2022.09.27

---

```
오버라이딩 vs 오버로딩

오버라이딩(overriding)은 상위클래스가 가지고 있는 메소드를 하위클래스가 재정의하여 사용하는 기술을 뜻하고 오버로딩은 매개변수와 타입의 개수를 변경하며 같은 이름의 메소드를 사용하는 기술입니다.
```

```
클래스 vs 객체 vs 인스턴스

**클래스**는 **객체**를 만들어 내기 위한 **설계도** 혹은 **틀**입니다.

**객체**는 **소프트웨어 세계에 구현할 대상**으로 **클래스를 기반으로 선언**되었기 때문에 클**래스의 인스턴스**라고도 부릅니다. 객체는 모든 **인스턴스를 대표**하는 포괄적인 의미를 갖습니다.

**인스턴스** 같은 경우는 **객체에 메모리가 할당되어 실제로 활용되는 객체**입니다. 그래서 **인스턴스는 객체에 포함**된다고도 볼 수 있습니다.

그래서 정리하자면 설계도인 클래스를 기반으로 소프트웨어 세계에 구현할 대상인 객체를 만든 후에 실제로 메모리에 할당하여 구체화하게되면 인스턴스라고 할 수 있겠습니다.
```

```
인터페이스 vs 추상 클래스

**인터페이스와** **추상 클래스** 둘 다 **인스턴스를 생성할 수 없으며**, **자식 클래스가 메소드의 구체적인 동작을 구현하도록 책임을 위임**합니다. 하지만 둘의 **목적**이 다른데 추상 클래스 같은 경우 자**식 클래스가 부모 클래스의 추상 메서드를 구체화하여 그 기능을 확장**하는데 목적이 있고 **인터페이스 같은 경우 서로 다른 클래스라도 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현해**야하는 경우에 사용합니다. 

둘의 **스펙상 차이**를 보면 **추상 클래스** 같은 경우 **단일 상속**만 할 수 있지만 **인터페이스는 다중 구현**이 가능하고, 추상 클래스는 **모든 접근 제어자를 사용**할 수 있는 반면 인터페이스는 **public 접근 제어자만 사용**가능 합니다. 그리고 **추상 클래스는 상수, 변수 둘다 선언 가능**하지만 **인터페이스는 상수**만 선언 가능합니다. 마지막으로 **추상 클래스는 추상 메서드 뿐 아니라 일반 메서드도 선언 가능** 하지만 **인터페이스는 추상 메소드만 선언 가능**합니다.
```

```
Java의 List, Set, Map

**List** 같은 경우 **데이터를 순차적으로 저장**하는데 **데이터의 중복과 null을 허용**한다.

- ArrayList: **단방향 포인트 구조**로 **각 데이터에 대한 인덱스를 가지고 있어 데이터 검색에 적합**하다. 하지만 **삽입, 삭제** 시 해당 데이터 이후 **모든 데이터가 복사**되므로 삽입, 삭제가 빈번한 데이터에는 **부적합**
- LinkedList: **양방향 포인터 구조**로 데이터의 삽입, 삭제 시 **해당 노드의 주소지만 바꾸면 되므**로 삽입, 삭제가 빈번한 데이터에 **적합**. 하지만 데이터 검색시 처음부터 노드를 순회하므로 **검색에 부적합**.
- Vector: 내부에서 자동으로 **동기화를 지원**해줘서 **병렬 처리에 안전**하지만, **느리고 무거워서 잘 사용하지 않는다.**

**Set** 같은 경우 **순서없이 Key로만 데이터를 저장**하는데 **Key의 중복을 허용하지 않는다.**

- HashSet: **저장 순서를 유지하지 않는 데이터의 집합**, **해시 알고리즘**을 이용해 **검색 속도가 매우 빠릅니다.**
- LinkedHashSet: **저장 순서를 유지**하는 HashSet입니다.
- TreeSet: **데이터가 정렬된 집합**으로 **Red Black Tree로 구현**이 되어있고 **Comparator를 이용해 정렬 방법 지정 가능**합니다.

**Map** 같은 경우 **순서없이 Key, Value로 데이터를 저장**하는데 **Value는 중복을 허용하지만 Key의 중복을 허용하지 않음.**

- HashMap: **Key와 Value로 데이터를 저장하는데 Key와 Value에 null을 허용하지 않음**. 배열의 i**ndex는내부 해쉬 함수를 통해 계산**한다. HashMap같은 경우 **동기화를 보장하지 않기** 때문에 **검색하는 속도가 빠르지만 신뢰성과 안정성이 떨어짐.**
- LinkedHashMap: **HashMap을 상속**받으며 저**장 순서를 유지**한다.
- TreeMap: **키값이 기본적으로 오름차순 정렬**되어 저장되고 **레드 블랙 트리로 구현**됩니다. **키값에 대한 정렬방법을 Comparator로 지정가능**합니다.
- ConCurrentHashMap: **Key와 Value에 null을 허용하지 않는다**. C**onCurrentHashMap 같은 경우도 동기화를 보장해서 멀티 쓰레드 환경에서 사용가능**한데 **HashTable의 단점을 보완**하기 위해서 나옴. **어떤 Entry를 조작하는 경우에만 락을 걸기 때문에 HashTable보다 데이터를 다루는 속도가 빠르다**.
- HashTable: **Key와 Value에 null을 허용하지 않는다**. **동기화를 보장하기 떄문에 멀티 쓰레드 환경에서 사용가능**하다. 하지만 **모든 메서드에서 동기화 락을 걸기 때문에 매우 느림**.
```

```
String vs StringBuffer vs StringBuilder

우선 **String**은 **immutable한 객체**이고 **StringBuffer**와 **StringBuilder**은 **muttable한 객체**입니다. **String은 한번 생성되면 할당된 메모리 공간이 변하지 않고 새로운 값을 추가하면 새로운 객체를 생성**해서 처리합니다. 그렇게되면 g**arbage collector가  호출되기 전까지 생성된 Stinrg은 힙 영역에 쌓이게 되어 문자열 연산이 많은 경우 그 성능이 좋지 않습**니다.  하지만 **Immutable 객체는 간단하게 사용가능**하고 **동기화에 신경쓰지 않아도되기 때문에** 내부 데이터를 자유롭게 공유 가능합니다.

S**tringBuffer와 StringBuilder** 같은 경우는 둘 다 **문자열 연산으로 기존 객체의 공간이 부족해지는 경우 동적으로 기존 사이즈를 늘리며** 유연하게 동작합니다. StringBuffer와 StringBuilder의 차이점은 **StringBuffer** 같은 경우 **모든 메서드에 Synchronized 키워드가 존재하여 동기화를 지원**해줍니다. 반면 **StringBuilder 같은 경우 동기화를 보장하지 않습니다**. 그러므로 **동기화가 필요한 경우라면 StringBuffer**를 사용하면 되고 필요없는 경우에는 **동기화 처리를 하지 않는 StringBuilder가 더 빠르기 때문에 StringBuilder를 사용**하면 됩니다.
```

```
Java8

**Java8**에서는 **함수형 프로그래밍**을 위해 **함수형 인터페이스와 람다, Stream Api가 추가** 되었고, **Null-safe**한 작업을 위해 **Optional API** 그리고 **Date와 Time을 함께 처리**하기 위해 **LocalDateTime API**등이 추가 되었습니다.

함수형 프로그래밍

**함수를 값**으로 생각해서 **함수의 함수의 함수.. 처럼 연속으로 처리**하는 프로그래밍 기법입니다. 이 함수는 **인풋과 아웃풋**이 있는데 **외부 환경에서 영향을 끼치지 않아** **같은 인풋이면 항상 같은 아웃풋을 내는 순수 함수**입니다.

람다

**불필요한 코드를 줄이고 가독성을 높이기 위한 익명 함수**로써, **함수 이름이나 반환타입 없이** 손쉽게 **함수를 선언**할 수 있습니다.

Stream API

**Stream API**같은 경우 **객체지향 언어인 Java를 함수형으로 프로그래밍할 수 있게 해주는 API**로써 코드를 간결하게 작성하게 해주어 **가독성을 높일 수** 있고 **병렬스트림과 같은 기술을 이용하면 처리 속도를 높일 수**도 있다. 하지만 잘**못 사용하면 오히려 성능이 떨어질 수** 있으며, **코드들이 추상화되어 있기 때문에 실수가 발생할 수** 있다.
```