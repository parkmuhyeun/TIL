# 2022.08.09
#etc/2022.08.09

---

```
## 운영체제란?

- 운영체제는 사용자가 컴퓨터를 편리하게 사용할 수 있도록 도와주는 소프트웨어
- 운영체제 사용의 가장 큰 목적은 하드웨어 관리
    - 컴퓨터에는 수 많은 하드웨어가 존재(CPU, 메모리, 디스크, 키보드, 마우스, 모니터 등)
    - 이를 잘 관리해주어야 컴퓨터를 효율적으로 사용
- 운영체제가 없다면 위에서 언급한 하드웨어에 관한 모든 관리를 사용자가 직접해야 되기 때문에 매우 불편할 것
- 즉, 운영체제는 컴퓨터의 성능을 높이고 사용자에게 편의성을 제공하는 프로그램

## 부팅 과정

1. 컴퓨터의 전원이 켜지면 프로세서(CPU)는 ROM에 있는 내용을 읽는데 그 중 먼저 POST를 실행시킨다.
    - ROM안에는 현재 컴퓨터의 상태를 검사하는 POST(Power-On Self-Test), 하드디스크에 저장되어 있는 운영체제를 찾아 RAM에 가지고 오는 부트 로더(boot loader)로 이루어져 있다.
2. POST 작업이 끝나면 부트로더가 실행되어 OS를 RAM으로 가져오게 된다.

## 운영체제 구성

운영체제는 크게 커널(Kernel)과 쉘(Shell)로 나뉘어집니다.

### 커널(kernel)

커널은 운영체제의 심장이자 뇌라고 할 수 있는데 대표적으로 여섯가지의 역할이 있다.

1. 시스템 콜 인터페이스: 애플리케이션이 OS를 통해서 어떤 처리를 하고 싶으면 **시스템 콜**이라고 하는 명령을 이용해서 커널에 명령을 내린다. 이때 명령이 **인터페이스**를 통해 전달된다. 예를 들어 은행이나 구청 등의 접수 창구와 같다고 생각하면 되겠다.
2. 프로세스 관리: OS는 수백, 수천개의 프로세스를 가동할 수 있는데 이에 비해 물리 서버의 CPU 코어 수는 많아봐야 수십개 정도밖에 안 된다. 그래서 언제, 어떤 프로세스가 **어느 정도 CPU 코어를 이용할 수 있는지, 처리 우선순위**를 어떻게 결정할 것인지 등을 관리한다.
3. 메모리 관리: 프로세스 관리는 CPU 코어를 고려했지만, 메모리 관리에서는 **물리 메모리 공간의 최대치를 고려**한다.
4. 네트워크 스택: 네트워크에서 발생하는 데이터 처리나 교환에는 다양한 구조가 존재하는데 커널이 **TCP/IP를 사용해서 간단히 통신할 수 있는 구조를 제공**한다.
5. 파일 시스템 관리: **파일 시스템용 인터페이스를 제공**한다. 우리가 사용하는 문서 파일이나 엑셀 파일은 물리 디스크에 기록된 데이터로는 ‘0111…’ 같은 숫자에 불과한데 파일 시스템 덕분에 애플리케이션은 ‘파일’ 단위로 데이터를 작성하거나 삭제할 수 있다. 이 시스템을 관리.
6. 장치 드라이버: **물리 장치용 인터페이스를 제공**, 각각의 물리 장치는 제조사가 다양하기 때문에 각각의 대응하는 애플리케이션을 만들기는 어렵다. 그래서 장치 드라이버를 이용해 그 아래에 있는 물리 장치를 은폐한다.

### 쉘(Shell)

쉘은 명령어 해석기로 사용자가 커널(운영체제)에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력한다. 사용자는 **GUI**(Grphical User Interface) 나 **CLI**(Command Line Interface) 같은 방식으로 운영체제 명령을 요청할 수 있다.
```

```
# 🔐 [암호화 알고리즘]

<aside>
💡 **암호**

두 사람이 안전하지 않은 채널(인터넷 등)을 통하여 정보를 주고받더라도 제 3자는 이 정보의 내용을 알 수 없도록 하는 것

</aside>

<aside>
💡 **관련 중요 개념 및 용어**

- **평문**(plaintext): 원본 메시지
- **암호문**(ciphertext): 코드화(암호화)된 메시지
- **암호화**(encryption): 평문을 암호문으로 변환
- **복호화**(decryption): 암호문을 평문으로 변환
- **키**(key): 암호화, 복호화 시 사용하는 가장 중요한 열쇠
</aside>

<aside>
💡 **일반적인 암호의 요건 ⇒ 암호 알고리즘 + 키(key)**

제 3자가 암호 알고리즘을 알더라도 키를 모르면 암호를 풀 수 없음

</aside>

# 🔑 대칭키와 공개키

## 대칭키

- 암호화와 복호화에 **동일한 키를 사용**하는 알고리즘
    
    → 하나의 비밀키를 양쪽(client & server)이 모두 같이 사용
    
- 장점 : 공개키 암호화 방식에 비해 계산 속도가 빠름
- 단점 : 송·수신자가 **동일한 키를 공유**해야 함 → 키가 노출되면 **기밀성이 보장되지 않아 문제가 발생**할 수 있음 (해킹 위험에 노출)
- 대표 알고리즘 : DES, AES, ARIA

---


## 공개키

- 대칭키 암호화 방식의 단점(키 전달 취약점)을 해결하기 위해 등장
- 암호화와 복호화에 **서로 다른 키를 사용**하는 알고리즘
    
    → 공개키(public key)와 개인키(private key) 두 개가 존재
    
- **암호화할 때는 공개키**, **복호화할 때는 개인키** 사용
- 공개키(public Key)만 대중에게 공개하고, 암호화된 데이터는 고유한 비밀키(private Key)로만 복호화할 수 있음. 이 비밀키를 가진 사용자만이 내용을 열어볼 수 있음
- 장점 : 키 관리가 쉽고, 대칭키의 단점(키 분배 문제)이 해결됨
- 단점 : 암/복호화 시 속도 느림
- 대표 알고리즘: RSA

### 🔒 공개키 암호화 시나리오

---


1. A가 웹상에 공개된 **B의 공개키**를 이용하여 평문을 암호화
2. 이 암호문은 B가 개인적으로 가지고 있는 **B의 비밀키**로만 복호화가 
   가능. B는 자신의 비밀키로 복호화 한 평문을 확인하고, **A의 공개키**
   로 응답을 암호화하여 A에게 송신
3. A는 **A의 비밀키**로 암호화된 응답 문을 복호화


# ⚒️ 하이브리드 방식 (대칭키 + 공개키)

- 대칭키를 주고받을 때만 공개키 암호화 방식을 사용하고, 이후에는 계속 대칭키 암호화 방식으로 통신 ⇒ **SSL(Secure Socket Layer)의 시초**가 됨


1. A가 **암호화 통신에 사용할 대칭키**를 **B의 공개키로 암호화**하고
   B에게 송신
2. B는 암호문을 받아 **자신의 비밀키**로 복호화
3. B는 A에게 보낼 평문을 **A로부터 얻은 대칭키로 암호화**하여 A에게 송신
4. A는 **자신의 대칭키**로 암호문을 복호화함
5. 이후에는 계속 이 대칭키로 암호화 통신

```