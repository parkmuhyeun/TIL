# 2022.10.10
#etc/2022.10.10

---

```
DBMS는 데이터베이스 내 데이터에 접근하도록 도와주는 시스템입니다. DBMS는 크게 질의처리기와 저장시스템으로 이루어져 있는데 질의처리기가 쿼리를 해석해서 파일시스템을 이용해 쿼리를 처리하고 캐싱합니다.

한 테이블의 여러개의 레코드가 다른 테이블의 여러개 레코드와 관계가 있는 경우입니다. N:M 관계를 설계할 때는 하나의 조인 테이블을 만들어 서로의 외래키를 저장해 편하게 관리할 수 있습니다.

# Index

## Index란?

인덱스는 **쓰기 작업과 저장 공간을 활용**하여 데이터베이스 테이블의 **검색 속도를 향상** 시키는 자료구조입니다.  인덱스가 없다면 테이블의 모든 데이터를 검색해 매우 느리기 때문에 인덱스라는 위치 색인을 이용해 빠르게 조회하는데 돕고있습니다.

primary key: 테이블의 **중복되지 않는 유일한 키**입니다.

그렇다고 Index를 **모든 컬럼에 생성하게 되면 오히려 좋지 않습니다**. Index같은 경우 **Insert, Update, Delete를 작업할 때 추가적인 과정**이 있기 때문에  오히려 시간이 늘어날 수 있습니다. 그렇기 때문에 **조회는 자주**하고 **수정 빈도가 낮으며** **데이터 중복이 적은 컬럼**을 선택하는게 좋습니다.

## Index 자료구조

Index 자료구조는 **B+ Tree를 일반적으로 사용**하는데 B+ Tree는 제일 위 노드인 **루트 노드**와 중간 노드인 **브랜치노드** 가장 아래 노드인 **리프노드**로 구성 되어 있습니다. **Binary Search Tree**와 비슷하지만 B+ Tree는 **자식노드가 2개이상이 가능**합니다.  key값을 이용해 찾고자하는 데이터를 **트리 구조**를 이용해 찾으며 리프노드는 **Linked List로 연결되어 순차검색에 용이**합니다.

그리고 **해시 테이블**을 사용할 수도 있는데 해시 테이블은 컬럼의 값을 **해싱 값**으로 계산해 **인덱싱**하는 알고리즘으로 **O(1)의 매우 빠른 검색**을 지원합니다. 하지만 값을 변형해서 인덱싱하기 때문에 값의 **일부만을 검색을 할 수 없습니다**.

Index 자료구조를 일반적으로 B+Tree를 사용하는 이유는  검색 쿼리 조건에는 **부등호같은 조건**도 있을 수 있는데 **동등 연산(equal)에 특화된 해시 테이블**을 사용하게 된다면 문제가 될 수 있습니다. 그리고 B+Tree는 **데이터 탐색 뿐아니라 삽입 및 수정 삭제도 항상 O(logn)**의 시간 복잡도를 가지기 때문입니다.

# 정규화

하나의 테이블에 정보를 담게 되면 **중복**뿐 아니라 **삽입 이상, 삭제 이상, 갱신 이상**이 발생할 수 있습니다. 이러한 문제를 해결하기 위해 **테이블을 나누게 되었으며 이를 정규화**라고 합니다. 보통 **1, 2, 3, BCN**F 정규화까지 진행하며, **4차부터는 비용이 많이** 들어서 잘 하지 않습니다.

삽입 이상: **튜플 삽입** 시 특정 속성에 해당하는 값이 없어 **NULL**을 입력해야 되는 현상입니다.

갱신 이상: 튜플 수정 시 **중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상**입니다.

삭제 이상: 튜플을 삭제 시 같이 저장된 **다른 정보까지 삭제되는 현상**입니다.

제1정규형: 모든 속성값이 **원자값**을 갖도록 분해합니다. 즉, **튜플의 애트리뷰트에 하나의 값**만 들어가야 된다는 뜻입니다.

제2정규형: **제1정규형을 만족**하고, 기본키가 아닌 속성이 **기본키에 완전 함수 종속**이도록 분해합니다. 여기서 완전 함수 종속이라는 뜻은 **기본키의 부분집합이 다른 값을 결정하지 않도록** 하는 것을 뜻합니다.

제3정규형: **제2정규형을 진행한 테이블**에 대해 **이행적 종속을 없애도록** 테이블을 분해합니다. 이행적 종속이란 **A→B에 종속 B→C에 종속되어, A→C에 종속되는걸 이행적 종속**이라 하는데 이를 A,B 로 나누고 B, C로 나누는걸 제3정규형이라고 합니다.

BCNF정규형: **제3정규형을 만족**하고, **모든 결정자가 후보키**가 되도록 테이블을 나눈 것입니다.  제3정규형과 BCNF의 차이는 **모든 결정자가 후보키이냐 아니냐**인데 제3정규형을 하고나서 모든 결정자가 후보키라면 할 필요가 없고 후보키가 아니라면 BCNF 정규형을 하면 됩니다.

# 트랜잭션(Transaction)

트랜잭션이란 **데이터베이스 상태를 변화** 시키는 **데이터베이스 작업의 단위**로써 하나 이상의 쿼리를 처리할 때 **동일한 Connection 객체**를 공유하여 **에러가 발생한 경우 모든 과정을 되돌리기 위한 방법**입니다.

트랜잭션의 특징으로 4가지가 있는데

1. 원자성(Atocimity): 트랜잭션에 포함된 작업은 **전부 수**행되거나 **전부 수행되지 않아야합니다**.
2. 일관성(Consistency): 트랜잭션을 수행하기 **전이나 후**나 데이터베이스는 **항상 일관된 상태**를 유지해야 합니다.
3. 고립성(Isolation): 각각의 트랜잭션은 **독립적으로 수행**되어야 합니다. 즉, 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 **변경중인 데이터 값을 훼손**시키지 않아야 합니다.
4. 지속성(Durabilty): 수행을 성공적으로 완료한 트랜잭션은 **변경한 데이터를 영구히 저장**해야 한다.

# RDB vs NoSQL

RDB

**2차원의 행과 열**로 데이터의 관계를 관리하는 데이터베이스입니다. **스키마**에 맞추어 데이터를 관리하기 때문에 데이터의 **정합성**을 보장할 수 있다. 하지만 시스템이 **커질수록 쿼리가 복잡**해지고 **성능이 떨어지며, 수평적 확장이 어렵습니다**.

NOSQL

RDB가 커짐에 따라 **관계가 복잡해지고 성능이 떨어져 이를 극복**하기 위해 등장하게 된 데이터베이스입니다. NOSQL은 **스키마가 없이 key-value형태**로 데이터를 관리하여 좀 더 **자유롭게 데이터를 관리**할 수 있고 RDB와 달리 **수평적 확장이 가능**합니다.  하지만 **중복된 데이터를  추가할 수 있어 잘 관리**해야 될 필요가 있습니다.

RDB는 **데이터 구조가 명확하여 변경될 여지**가 없으며 **명확한 스키마가 중요**한 경우  사용하는 것이 좋고 NOSQL은 **정확히 데이터 구조를 알 수 없고 변경/확장할 가능성**이 있는 경우에 사용하면 좋습니다.

# Join

**관계형 데이터베이스** 같은 경우 **여러 테이블**로 나눠지기 때문에 각 테이블에 저장된 데이터를 **효과적으로 검색**하기 위해 **여러 테이블의 레코드를 조합하여 하나의 열**로 나타낸 것입니다.

내부 조인(INNER JOIN)

INNER JOIN 같은 경우 조인하는 테이블의 **교집합**을 의미합니다. 즉, **겹치지 않는 행들은 결과에서 제외**됩니다.

외부 조인(OUTER JOIN)

OUTER JOIN은 조인 대상 테이블에서 **특정한 테이블의 데이터가 모두 필요한 경우**에 외부 조인을 활용하여 **효과적인 결과 집합을 생성** 가능합니다.

LEFT OUTER JOIN

**왼쪽 테이블의 모든 데이터**를 포함하는 결과를 생성합니다.

RIGHT OUTER JOIN

**오른쪽 테이블의 모든 데이터**를 포함하는 결과를 생성합니다.

FULL OUTER JOIN

**양쪽 테이블 모든 데이터 포함**하는 결과 생성합니다.

INNER JOIN과 OUTER JOIN의 차이는 INNER JOIN 같은 경우 교집합이기 때문에 **겹치지 않으면 결과에서 제외**됩니다. 하지만 LEFT OUTER JOIN 같은 경우 왼쪽 테이블을 모두 포함하고 **조건과 맞지 않는 행은 NULL로 채우게 됩니다**.
```