# 2022.08.25
#etc/2022.08.25

---

```
## 정규화(Normalization)란?

데이터베이스 정규화란 관계형 데이터베이스의 설계에서 **중복을 최소화**하게 데이터를 구성하는 프로세스이다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것이다. 정규화를 통해 불필요한 데이터를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상을 방지할 수 있다.

예를들어 정규화를 하지 않았을 때 문제점을 보면

위의 그림과 같이 정규화1가 되지 않은 테이블의 경우 중복(Adam이라는 학생이 두번)뿐 아니라, 데이터를 처리할 때 다양한 이상현상이 발생

1. 삽입: 어떤 학생이 아무 과목도 수강하지 않으면, Subject_opted 에는 Null
2. 갱신: 위의 테이블에서 Adam의 Address가 변경되면 여러줄 데이터를 갱신해야함 -> 데이터 불일치 발생 가능
3. 삭제: Alex학생이 과목 수강을 취소한다고 삭제해버리면 Alex라는 레코드가 아예 삭제됩니다.

이렇게 다양한 문제점이 발생할 수 있기 때문에 정규화가 필요하다. 정규화에는 1, 2, 3, BCNF, 4, 5차 정규화까지 있는데 보통 3차까지 해도 충분하다고 하며 4, 5차 까진 비용의 문제로 잘 하지 않는다고 한다.

## 1차 정규화

**제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 나누는 것이다.** 예를 들어, 아래와 같은 경우 Adam이 Subject를 두 개 가지고 있기 때문에 1차 정규형을 만족하지 못한다.

위의 테이블을 1정규화를 하게 되면 아래처럼 한 개의 행을 더 만들게 된다. 만약 하나의 열에 여러 개의 데이터가 들어가 있으면 어떤 학생이 같은 Subject를 듣는가? 같은 쿼리를 검색하기 힘들다. 물론 데이터를 추출해서 검색할 수 있겠지만 매우 불편할 것이다. 그리고 수정한다고 해도 전체 내용을 수정해 줘야 되고 해주는 과정에서도 혹시 빠트리기도 하면 큰일이 날 수 있다.

## 2차 정규화

**제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 나누는 것을 의미한다.** 즉, 기본키중에 특정 컬럼에만 종속된 컬럼(부분적 종속)이 없어야 한다.

아래와 같은 테이블이 좋지 않은 이유는 위에서도 말했지만 갱신이상이 발생한다. 예를들어 자료구조에 따라 강의실이 결정되는데 502번의 자료구조 강의실만 공학관113으로 변경된 경우 자료구조의 강의실은 공학관 113, 공학관 111로 데이터가 불일치하게 됩니다.


위 테이블에서는 기본키가 (학생번호, 강좌이름)으로 복합키인데 (학생번호, 강좌이름)인 기본키가 성적을 결정하고 있다. ((학생번호, 강좌이름) -> (성적)) 그런데 강의실이라는 컬럼은 기본키 부분집합중 강좌이름에 의해 결정될 수 있다. ((강좌이름) -> (강의실)) 즉, 기본키(학생번호, 강좌이름)의 부분키인 강좌이름에 종속되는 컬럼이 있기 때문에 제2 정규형을 만족하지 못하고 아래처럼 나눠 제2 정규형을 만족시킬 수 있다.

## 3차 정규화

**제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.** 여기서 이행적 종속이란 A -> B, B -> C 일 때, A -> C가 성립되는 것을 의미한다.

위 테이블을 보면 학생 번호는 강좌 이름을 결정하고 있고 강좌 이름은 수강료를 결정하고 있다. (학생번호 -> 강좌이름, 강좌이름 -> 수강료) 그렇기 떄문에 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해할 필요가 있다.

이런 이행적 종속을 제거하는 이유는 예를 들어 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경된 경우 501번 학생은 스포츠경영학이라는 수업을 20000원으로 듣게 된다. 수강료를 15000원으로 맞게 고칠 수 있지만 변경을 한번 더 해야된다는 번거로움이 있는데 이걸 해결하기 위해 제3 정규화를 한다.

## BCNF 정규화

**BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 나누는 것이다.**

> 후보키: 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
> 

위 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키 (학생번호, 특강이름)는 교수를 결정하고 있는데 교수 또한 특강이름을 결정하고 있다. 그런데 교수는 특강이름을 결정하는 결정자이지만 후보키가 아니기 때문에 BCNF를 만족하지 못하며 만족시키기 위해선 아래처럼 테이블을 분해되야 된다.

```

```
# 1. **CPU란?**

### ● CPU : **Central Processing Unit (중앙 처리 장치)**

→ 프로그램을 실행하기 위해 메인 메모리에서 명령어를 인출하여 해독하고 실행한다.

1. 연산
    - 덧셈, 뺄셈, 곱셈 등의 산술 연산과 논리곱, 논리합, 부정 등의 논리 연산을 수행
2. 제어
    - 명령어를 순서대로 실행할 수 있도록 제어
3. 저장
    - 연산에 필요한 데이터, 연산 결과, 명령어 주소 등을 임시로 저장

# 2. **CPU의 구조**
1. **산술 논리 연산장치 (ALU, Arithmetic Logic Unit)**
    - 산술 및 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈
        
        (  산술 : +,-,×,÷,   논리 : AND, OR, NOT 등 )
        
2. **레지스터 (Register)**
    - CPU 내부에 있는 기억장치 (메모리)
        - 고속 기억장치 → 액세스 속도가 컴퓨터의 기억장치들 중에서 가장 빠름
    - 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장
    - 내부 회로가 복잡하여 비교적 큰 공간을 차지 → CPU 안에 많이 포함시키기 어려움
        - 지정된 용도로 사용되는 특수 목적용 레지스터와 적은 수의 일반 목적용 레지스터가 있음
3. **제어 장치 (Control Unit)**
    - 프로그램 코드(명령어)를 해석하고, 그것을 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈
    - 각 장치들의 동작을 결정하는 신호를 보냄
    - 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치로 보냄

# 3. **핵심 특수 목적 레지스터**

---

- **프로그램 카운터(PC)** : 다음에 수행할 명령어의 주소를 저장
- **명령어 레지스터(IR)** : 현재 실행 중인 명령어를 저장
- **누산기(AC)** : 연산 결과를 임시로 저장
- **메모리 주소 레지스터(MAR)** : 읽기와 쓰기 연산을 수행할 주기억장치의 주소를 저장
- **메모리 버퍼 레지스터(MBR)** : 주기억장치에서 읽어온 데이터나 주기억장치에 저장할 데이터를 임시로 저장

# 4. **CPU의 동작 과정**

---

1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장한다.
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보낸다.
4. 제어장치는 명령어가 순서대로 실행되도록 각 장치를 제어한다.
```