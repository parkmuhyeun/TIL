# 2022.08.18
#etc/2022.08.18

---

```
우리는 인터넷을 하고 있는 동시에 음악도 들을 수 있고 채팅도 할 수 있다. 어떻게 컴퓨터는 동시에 처리할까? 컴퓨터는 사실 동시에 처리하는 것이 아니라 각 프로그램을 일정시간 동안 번갈아가면서 실행(TIME SHARING)하고 있는데 그 속도가 매우 빨라서 우리가 동시에하고 있는 것처럼 느낄뿐이다.

프로세스들이 교체되어 수행되고 나면 다시 원래 하고 있던 프로세스를 불러와야 되는데 그때 원래 하던 작업을 기억하고 있어야 겠죠. 이때 프로세스 단위로 정보를 저장하는 구조가 바로 PCB(Process Control Block)입니다.

## PCB(Process Control Block) 란?

- 운영체제가 프로세스를 제어하기 위한 정보를 저장해놓는 곳으로, 프로세스 상태 정보를 저장하고 있는 구조체
- 프로세스 상태 관리와 문맥교환(Context Swiching)을 위해 필요
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지

다시 한번 예로 들면, 기존에 어떤 프로세스를 작업하고 있는데 급한 프로세스가 처리해달라고 요청이 오면 원래 하던 프로세스를 어딘가에 임시 저장을 해놓아야 급한 프로세스를 처리하고 나서도 다시 원래하던 애를 이어서 할 수 있겠죠. 즉, 프로세스에 대한 상태 정보를 저장할 공간이 필요한데 그게 바로 PCB입니다.

## PCB 저장 정보

- Process ID: 프로세스 고유 식별번호로, PID(Process Identification Number)라고도 한다.
- Process State(프로세스 상태): 프로세스의 현재 상태(준비, 실행, 대기 등의 상태)를 저장
- Program Counter(계수기): 다음에 실행되는 명령어의 주소를 저장
- Process Priority(스케줄링 정보): 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 저장
- CPU Registers: 프로세스의 레지스터 상태를 저장하는 공간
- Account(계정 정보): CPU 사용시간, 각종 스케줄러에 필요한 정보 저장
- 입출력 정보: 프로세스 수행 시 필요한 주변 장치, 파일등의 정보를 저장

이렇게 프로세스에 대한 상태를 저장한 PCB에 의존하여 프로세스를 변경하는데, 다른 프로세스로 변경하는 것을 Context Switching이라 한다.

## Context Switching

멀티 프로세스 환경에서 CPU가 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스 상태 값을 PCB에 저장하고 CPU가 다음 프로세스를 실행할 수 있도록 다음 PCB를 읽어 교체하는 작업을 Context Switching이라 한다.

### Context Switching 과정

1. 현재 CPU는 process P0을 수행하고 있다가 인터럽트(interrupt)가 걸리게되면 현재 수행하고 있는 것을 먼저 PCB0에 저장을 한다.
2. Waiting 상태로 변하게 되면 CPU는 다른 프로세스(process P1)을 Running으로 바꿔 올린다.
3. CPU가 앞으로 수행할 프로세스(process P1)에 관한 정보로 교체
4. 이번에는 CPU가 process P1을 수행하다 다시 인터럽트(interrupt)가 걸리면 현재 수행하고 있는 것을 PCB1에 저장한다.
5. Waiting 상태로 변하게 되면 CPU는 다른 프로세스(process P0)을 Running으로 바꿔 올린다.
6. CPU가 앞으로 수행할 프로세스(process P0)에 관한 정보로 교체

### 왜 Context Swiching이 필요?

만약 컴퓨터 매번 하나의 Task만 처리한다면 다음 Task를 처리하기 위해선 현재 Task가 끝날 때까지 기다려야 되기 때문에 매우 불편하다. 그래서 동시에 사용하는 것처럼 하기 위해 Context Switching이 필요하게 되었다.

## Context Switching 오버헤드

현재 Context Switching 과정을 보면 P0이 수행되다가 P1이 되고 P1을 수행하다 다시 P0이 수행이 실행이 된다. 이렇게 계속 교체가 되면 현재 수행되던 프로세스를 메모리에 저장하고, 다음 수행할 프로세스를 CPU에 넣어야 되는 이런 번거로운 일(overhead)이 추가가 되는데 왜 이렇게 하는 걸까? 그냥 P0을 한번에 한 다음 P1을 하면 되지 않을까?

프로세스 수행 중 입출력 이벤트가 발생했을 때 CPU를 사용하지 않게 되는데 이 CPU가 낭비되는 시간 동안 차라리 overhead가 발생하더라도 Context Switching을 통해 다른 프로세스를 실행시키는 게 전체적으로 봤을 때 더 효율적이기 때문에 overhead를 감수하고 Context Switching을 하는 것이고 그래서 운영체제가 CPU를 관리하는 것이다.
```

```
# IPC (Inter-Process Communication)

# 1. [정의]

- 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로 (Wikipedia)

# 2. 등장 배경

<aside>
💡 **프로세스끼리 직접적으로 ‘대화’하는 방법이 없기 때문**

</aside>

### **프로세스(Process)**

- 실행 중인 응용 프로그램
- 메모리 구조를 그대로 가지고 있음
- CPU 자원을 할당 받아 프로그램이 실행되고 있는 상태

### Q. **프로세스 간 커뮤니케이션 가능한가?**

- 원칙적으로 불가능
- 프로세스 간 메모리 영역을 공유하지 않기 때문
- 왜?  → 서로의 공간을 접근할 수 있다면 프로세스의 데이터/코드가 바뀔 수 있기 때문에 이를 원칙적으로 접근할 수 없게 함

<aside>
💡 제가 만든 작고 소중한 코드가 나쁜 해커놈들이 만든 프로그램으로 인해 조작되서 중요한 데이터를 뺏기면 마음도 아프고 그렇겠죠? 이를 막기 위해 프로세스는 통신을 직접적으로 할 수가 없고, 서로의 공간을 접근할 수가 없어요. 그래도 프로세스 간의 커뮤니케이션은 필요하기 때문에 나온 기법이라 할 수 있어요.

</aside>

### Q. **그렇다면 프로세스 간 커뮤니케이션이 필요한가?**

- 그렇다.
    
    → 여러 프로세스를 만들어 동시 실행함으로 실행 속도를 높여 **성능을 높일 수 있기 때문**
    
    → 이 때, 프로세스 간 상태 확인 및 데이터 송·수신이 필요함 (로직을 수행하는 과정에서 필요한 데이터들의 공유가 필요)
    
- 예시를 들자면
    
    CPU의 core는 여러 개 존재하며, 각 core에서 동시에 실행한 뒤 최종 작업을 위해 특정 Process에서 모아 결과를 처리해야 함
    
    이때 프로세스 간 통신이 필요함
    

⇒ 정리하자면, 프로세스 간 커뮤니케이션(통신)은 **각 처리를 병렬로 처리해 통합함으로 생산성을 높이기 위해** 필요함

- 간단하게 생각해보자. 프로세스 간 통신을 통해 1부터 10,000까지의 수를 더해보자.
    
    → fork() 함수로 10개의 프로세스를 만들어, 각 프로세스에서 1천 단위로 더하기를 수행한 다음 각 프로세스의 결과 값을 합하면 더욱 빠른 처리가 가능함
    
    → 즉, 계산을 병렬처리함으로 수행시간을 단축시킨 것이며, 각 프로세스가 더한 값을 수집해야 하기에 프로세스 간 통신이 필요함
    

# 3. 종류 (주요 IPC 기법)

- 전통적인 주요 기법 두 가지가 있음
- **메세지 전달 기법 (Message Passing)**
    - 프로세스 간 공유 데이터 없이 메세지를 주고받아 통신
- **공유 메모리 기법 (Shared Memory)**
    - 프로세스들이 주소 공간의 일부를 공유
    - 원칙적으로 개별 공간이지만 시스템 콜로 공유를 지원
    - 물리적 메모리에 매핑 시 공유 메모리 주소 영역은 A, B 프로세스가 서로 같은 주소에 매핑됨
    - **동기화 문제** : 커널이 책임지지 않으므로 프로세스들끼리 직접 해결해야 함
```