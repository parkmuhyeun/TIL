# Software Development
#Data Processing Engineer/Software Development

```
소프트웨어 개발

자료구조
프로그램에서 사용하기 위한 자료를 기억장치의 공간 내에 
저장하는 방법과 자료 간의 관계, 처리 방법 등을 저장 공간의 
효율성 및 실행 간의 신속성을 높이기 위한 연구 분석하는 것

배열
동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합
- 첨자(index)를 이용하여 데이터에 접근

리스트
 자료를 나열한 목록

선형 리스트(Linear List)
일정한 순서에 의해 나열된 자료 구조)
ㄱ.연속 리스트(Contiguous List)
배열과 같이 연속되는 기억장소에 저장되는 자료 구조
- 중간에 데이터를 삽입하기 위해 연속된 빈 공간이 있어야 하며 삽입, 삭제 시 자료의 이동 필요
ㄴ. 연결 리스트(Linked List)
자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조 
- 기억 공간이 연속적으로 놓여 있지 않아도 저장 가능

스택(Stack) - 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조
- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리

큐(Queue)
리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조
- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO; First In First Out) 방식으로 처리

트리(Tree)
정점과 선분을 이용하여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태

데이터저장소 / DB / DBMS

데이터저장소
소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적

데이터베이스(DB)
특정 조직의 업무를 수행하는데 필요한 데이터들의 모임

DBMS(DataBase Management System)
사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리하는 소프트웨어

DBMS의 기능
ㄱ. 정의 기능 
데이터베이스에 저장될 데이터의 타입과 구조에 대해 명시하는 기능
ㄴ. 조작 기능 
데이터를 검색, 갱신, 삽입, 삭제 등 처리하기 위해 사용자와 데이터베이스 간 인터페이스 수단을 제공하는 기능
ㄷ. 제어 기능
a. 데이터의 무결성이 유지되도록 제어
b. 사용자에게 허가된 데이터만 접근하도록 보안을 유지하고 권한을 검사
c. 여러 사용자가 동시에 접근하여 데이터를 처리할 때 정확성을 유지하도록 병행 제어
DBMS의 장단점
ㄱ. 장점
a. 데이터 독립성, 일관성, 무결성 유지
b. 보안 유지
c. 데이터 실시간 처리, 통합 관리, 표준화 가능
ㄴ. 단점
a. 전문가 부족
b. 전산화 비용 증가
c. 파일의 백업과 회복이 어려움
d. 시스템이 복잡함

데이터 입출력
소프트웨어의 기능을 구현하기 위해 데이터베이스에 데이터를 입력, 출력하는 작업

SQL( Structured Query Language 구조화 질의어)
- 국제 표준 데이터베이스 언어
- 데이터 정의어, 조작어, 제어어로 구분됨

데이터 접속(Data Mapping)
프로그래밍 코드와 데이터베이스의 데이터를 연결하는 것

트랜잭션
하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행돼야 할 일련의 연산
ㄱ. TCL(Transaction Control Language) : 트랜잭션을 제어하기 위해 사용되는 명령어
ㄴ. COMMIT : 트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을 데이터베이스에 반영
ㄷ. ROLLBACK : 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌림
ㄹ. SAVEPOINT(CHECKPOINT) : 트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정

절차형 SQL
프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL

단위 모듈 구현

단위 모듈
소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것

단위 모듈 구현 순서
단위 기능 명세서 작성 -> 입출력 기능 구현 –> 알고리즘 구현
ㄱ. 단위 기능 명세서 작성
ㄴ. 입출력 기능 구현
단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터 구현
ㄷ. 알고리즘 구현
입출력 데이터를 바탕으로 단위 기능별 요구 사항들을 구현 가능 언어를 이용하여 모듈로 구현

IPC(Inter Process Communication) 
모듈 간 통신을 구현하기 위해 사용되는 프로그래밍 인터페이스 집합
a. 공유 메모리 : 다수의 프로세스가 공유 가능한 메모리를 구성하여 통신 수행
b. 소켓 : 네트워크 소켓을 이용하여 네트워크를 경유하는 통신 수행
c. 세마포어 : 공유 자원에 대한 접근 제어를 통해 통신 수행
d. 파이프 : 선입선출의 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
e. 메시지 큐잉 : 메시지가 발생하면 이를 전달하는 형태로 통신 수행

단위 모듈 테스트 
모듈이 정해진 기능을 정확히 수행하는지 검증

테스트 케이스
구현된 소프트웨어가 요구사항을 정확히 준수했는지 확인하기 위한 테스트 항목에 대한 명세서로 명세 기반 테스트의 설계 산출물에 해당

테스트 프로세스
테스트를 위해 수행하는 작업이 테스트의 목적과 조건을 달성할 수 있도록 도와주는 과정

개발 지원 도구

통합 개발 환경(IDE : Integrated Development Environment)
개발에 필요한 편집기, 컴파일러 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공

빌드 도구
소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물

협업 도구
개발에 참여하는 사람들이 서로 다른 작업 환경에서 프로젝트를 수행할 수 있도록 도와주는 도구

소프트웨어 패키징
실행 파일을 묶어 배포용 설치 파일을 만드는 것

패키징시 고려사항
- 사용자의 운영체제, CPU, 메모리 등에 필요한 최소 환경 정의
- UI는 시각적인 자료와 함께 매뉴얼과 일치시켜 패키징
- 소프트웨어는 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공

패키징 작업 순서
기능 식별 -> 모듈화 -> 빌드 -> 사용자 환경 분석 ->패키징 및 적용 시험 -> 패키징 변경 및 개선 -> 배포

릴리즈 노트 작성
릴리즈 노트(배포 노트)
개발 과정에서 정의된 릴리즈 정보를 고객에게 공유하기 위한 문서

릴리즈 노트 초기 버전 작성 시 고려사항
- 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성
- 신규 코드, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성

릴리즈 노트 추가 버전 작성 시 고려사항
- 테스트 과정에서 베타 버전이 출시되거나 긴급 버그 수정, 업그레이드, 사용자 요청 등의 특수한 상황의 경우 작성
- 긴급 버그 수정 시 수정하는 경우 릴리즈 버전을 출시하고 그 번호를 포함한 모든 내용을 수정된 내용을 담음
- 요구사항에 의해 추가 혹은 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전으로 출시하고 작성


디지털 저작권 관리

저작권
창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한

디지털 저작권 관리(Digital Right Management)
저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 생성, 유통, 이용까지 전 과정에 걸쳐 사용
되는 디지털 콘텐츠 관리 및 보호 기술

디지털 저작권 관리의 흐름도
ㄱ. 클리어링 하우스 : 저작권에 대한 사용 권한, 라이선스 발
급, 사용량에 따른 결제 관리 등 수행
ㄴ. 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
ㄷ. 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태
로 묶어 암호화 하는 프로그램
ㄹ. 콘텐츠 분배자 : 암호화된 콘텐츠를 유통
ㅁ. 콘텐츠 소비자 : 콘텐츠를 구매해서 사용
ㅂ. DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 
프로그램
ㅅ. 보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 
전자적 보안 장치

디지털 저작권 관리의 흐름도(?)

디지털 저작권 관리의 기술 요소
- 암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증

소프트웨어 설치 매뉴얼 작성

소프트웨어 설치 매뉴얼
개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 문서

소프트웨어 사용자 매뉴얼
사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 기록한 문서

소프트웨어 버전 등록

소프트웨어 패키징 형상 관리 
형상관리는 소프트웨어의 변경 사항을 관리하기 위한 활동

형상 관리의 중요성
- 지속적으로 변경사항을 체계적으로 관리 및 추적할 수 있음
- 발견된 버그나 수정 사항을 추적
- 무절제한 변경 방지

형상 관리 기능
ㄱ. 형상 식별 : 대상에 이름과 관리 번호를 부여하고 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
ㄴ. 버전 제어 : 소프트웨어 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고 특정 절차와 도구를 결합하는 작업
ㄷ. 형상 통제 : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 하는 작업
ㄹ. 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
ㅁ. 형상 기록 : 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

소프트웨어 버전 등록 관련 주요 용어
ㄱ. 저장소(Repository) : 형상에 대한 정보들이 저장되어 있는 곳
ㄴ. 가져오기 : 아무것도 없는 저장소에 처음으로 파일 복사
ㄷ. 체크아웃 : 저장소에서 소스 파일, 버전 관리를 위한 파일을 받아옴
ㄹ. 체크인 : 체크아웃으로 받아온 파일을 수정 후 저장소에 새로운 버전으로 갱신
ㅁ. 커밋 : 체크인 수행 시 이전에 갱신된 내용이 있는 경우 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신
ㅂ. 동기화 : 저장소에 있는 최신 버전을 동기화

소프트웨어 버전 관리 도구

공유 폴더 방식
버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리

클라이언트/서버 방식
버전 관리 자료가 서버에 저장되어 관리

분산 저장소 방식
버전 관리 자료가 하나의 원격 저장소와 분산된 PC의 로컬 저장소에 함께 저장되어 관리

Subversion(SVN) - 아파치 소프트웨어 재단에서 2000년에 발표
- 클라이언트/서버 방식
- 모든 작업은 trunk 디렉토리에서 추가 작업은 branches 디렉토리 안에 별도의 디렉토리를 만들어 작업 후 trunk 디렉
토리와 병합
- 커밋 시 커밋의 버전인 리버전이 1씩 증가
- 서버는 주로 유닉스에서 사용

Git - 리누스 토르발스즈가 2005년에 개발
- 분산 저장소 방식

빌드 자동화 도구

빌드 자동화 도구
소스 코드를 컴파일한 후 여러 개의 모듈로 묶어 실행 파일로 만드는 과정을 포함하여 테스트 및 배포를 자동화하는 도구

Jenkins(젠킨스)
젠킨스(Jenkins)는 소프트웨어 개발 시 지속적 통합서비스를 제공하는 툴이다. 다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유 영역에 있는 Git등의 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해 준다
- 서블릿 컨테이너에서 실행되는 서버 기반 도구
- 형상 관리 도구와 연동 가능
- Web GUI 제공으로 사용이 쉬움
- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

Gradle(그레이들)
Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구(Groovy는 아파치의 자바 가상 머신에서 작동하는 동적 타이
핑 프로그래밍 언어이다)
- 안드로이드 앱 개발 환경에 사용
- Java, C/C++, Python 등의 언어도 빌드 가능
- Groovy를 사용해서 만든 DSL(Domain-specific language)을 스크립트 언어로 사용
- 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
- 이전의 태스크를 재사용하거나 다른 시스템의 태스크를 공 유하여 빌드의 속도를 향상시킬 수 있음

```

```
애플리케이션 테스트

애플리케이션 테스트
애플리케이션에 잠재된 결함을 찾아내는 과정


애플리케이션 테스트의 필요성
- 미리 오류를 발견하고 새로운 오류의 유입 예방
- 사용자의 요구사항에 만족하는지 테스트해 제품의 신뢰도 향상

애플리케이션 테스트의 기본 원리
- 잠재적인 결함을 줄일 수 있지만 소프트웨어 자체 결함이 없다곤 할 수 없음
- 작은 부분에서 시작해서 점점 확대하며 진행

애플리케이션 테스트 분류

프로그램 실행 여부
ㄱ. 정적 테스트
프로그램을 실행하지 않고 소스코드나 명세서를 분석하여 테스트
ㄴ. 동적 테스트
프로그램을 실행하여 테스트
- 개발의 모든 단계에서 진행
- 블랙박스 테스트, 화이트 박스 테스트

테스트 기반
ㄱ. 명세 기반 테스트
사용자의 요구사항을 테스트 케이스로 만들어 구현하고 있는지 확인하여 테스트
- 동등 분할, 경계 값 분석
ㄴ. 구조 기반 테스트
소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 만들어 테스트
ㄷ. 경험 기반 테스트
테스터의 경험을 기반으로 테스트

시각
ㄱ. 확인 테스트
사용자의 시각에서 결과를 테스트
ㄴ. 검증 테스트
개발자의 시각에서 과정을 테스트

목적에 따른 테스트
ㄱ. 회복 테스트 : 결함을 주고 잘 복구되는지 테스트
ㄴ. 안전 테스트 : 시스템 보호 도구가 불법적인 침입으로부터 보호할 수 있는지 테스트
ㄷ. 강도 테스트 : 과부하 시 정상적으로 실행되는지 테스트
ㄹ. 성능 테스트 : 응답 시간, 처리량 등을 테스트
ㅁ. 구조 테스트 : 내부의 논리적인 경로, 소스 코드 복잡도 등을 평가
ㅂ. 회귀 테스트 : 변경 혹은 수정에 따른 새로운 결함이 없는지를 테스트
ㅅ. 병행 테스트 : 기존의 소프트웨어와 변경된 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트

동적테스트

화이트박스 테스트
모듈의 원시 코드를 오픈하여 논리적인 모든 경로를 한번 이상 실행하면서 테스트하여 테스트 케이스를 설계

화이트박스 테스트의 종류
ㄱ. 기초 경로 검사
: 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
ㄴ.제어 구조 검사
a. 조건 검사 : 프로그램 내의 논리적 조건을 테스트
b. 루프 검사 : 프로그램 내의 반복 구조에 초점을 맞춰 테스트
c. 데이터 흐름 검사 : 프로그램 내의 변수의 정의와 사용의 위치에 초점을 맞춰 테스트

화이트박스 테스트 검증 기준
ㄱ. 문장 검증 기준 : 모든 구문이 한 번 이상 수행되도록 설계
ㄴ. 분기 검증 기준 : 모든 조건문이 한 번 이상 수행되도록 설계
ㄷ. 조건 검증 기준 : 모든 조건문에 대해 참/거짓인 경우가 한번 이상 수행되도록 설계
ㄹ. 분기/조건 기준 : 모든 조건문과 조건문에 포함된 개별 조
건식의 결과가 참/거짓인 경우가 한번 이상 수행되도록 설계

블랙박스 테스트
소프트웨어가 수행할 특정 기능을 알기 위해 기능이 완전히 작동되는 것을 입증하는 기능 테스트

블랙박스 테스트의 종류
ㄱ. 동치(동등) 분할 검사 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사
ㄴ. 경계값 분석 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사
ㄷ. 원인-효과 그래프 검사 : 입력 데이터 간의 관계과 출력의 영향을 미치는 상황을 분석 후 효용성이 높은 테스트 케이
스를 선정하여 검사
ㄹ. 오류 예측 검사 : 과거 경험이나 확인자의 감각으로 테스트
ㅁ. 비교 검사 : 여러 프로그램에 동일한 테스트 자료를 제공하여 동일한 출력이 나오는지 확인하는 검사

단위 테스트
코딩 직후 모듈이나 컴포넌트에 초점을 맞춰 하는 테스트

통합 테스트
단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성하는 과정에서 테스트 

ㄱ.비점진적 통합 방식
a. 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트
ㄴ.점진적 통합 방식
a. 모듈 단위로 단계적으로 통합하면서 테스트
b. 하향식 / 상향식 / 혼합식 테스트 방식
ㄷ. 하향식 통합 테스트
a. 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
ㄹ. 상향식 통합 테스트
a. 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
ㅁ. 혼합식 통합 테스트
- 하위 수준에서는 상향식 통합 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원
ㅂ. 회귀 테스트
- 이미 테스트된 프로그램의 테스트를 반복

시스템 테스트
개발된 소프트웨어가 원하는 환경에서 수행되는지 테스트
- 실제 환경과 유사하게 만든 테스트 환경에서 진행

인수 테스트
: 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트
- 사용자가 직접 테스트
ㄱ. 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부 확인
ㄴ. 운영상의 인수 테스트 : 시스템 관리자가 시스템 인수 시 수행
ㄷ. 계약 인수 테스트 : 계약상의 조건을 준수하는지 확인
ㄹ. 규정 인수 테스트 : 규정에 맞게 개발되었는지 확인
ㅁ. 알파 테스트 : 개발된 환경에서 사용자가 개발자 앞에서 수행
ㅂ. 베타 테스트 : 사용자의 환경에서 사용자가 직접 테스트 수행

애플리케이션 테스트 프로세스
개발된 소프트웨어가 제대로 만들어 졌는지 테스트하는 절차
- 테스트를 마치면 테스트 계획서, 케이스, 시나리오, 결과서가 산출

테스트 케이스 / 시나리오 / 오라클

테스트 케이스
사용자의 요구사항이 준수되었는지 확인하기 위해 테스트 항목에 대한 명세서

테스트 시나리오
- 테스트 케이스를 적용하는 구체적인 절차를 명세한 문서

테스트 오라클
테스트 결과가 올바른지 판단하기 위해 정의된 참 값을 대입하여 비교

테스트 오라클의 특징
ㄱ. 제한된 검증 : 모든 테스트 케이스에는 적용 불가
ㄴ. 수학적 기법 : 수학적 기법을 통해 테스트 오라클 값을 구할 수 있음
ㄷ. 자동화 기능 : 테스트 대상에 대한 실행, 결과 비교 등을 자동화할 수 있음

테스트 오라클의 종류
ㄱ. 참 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공
ㄴ. 샘플링 오라클 : 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공
ㄷ. 추정 오라클 : 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고 나머지 값에 대해서는 추정으로 처리
ㄹ. 일관성 검사 오라클 : 변경 시 테스트 케이스 수행 전과 후의 결과 값이 동일한지 확인

43. 테스트 자동화 도구
테스트 자동화
 반복적인 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용하여 쉽고 효율적으로 테스트 수행

테스트 자동화 도구의 장단점
ㄱ. 장점
a. 반복적인 작업을 자동화해 인력 및 시간 절감
b. 향상된 테스트 품질 보장
c. 사용자의 요구사항 등을 일관성 있게 검증
d. 테스트 결과에 대한 객관적인 평가 기준 제공
e. 테스트 결과를 다양한 표시 형태로 제공
f. UI가 없는 서비스도 정밀 테스트 가능
ㄴ. 단점
a. 사용방법에 대한 교육 및 학습 필요
b. 자동화 도구를 프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요

테스트 자동화 수행 시 고려사항
- 모든 과정이 아닌 그때그때 맞는 적절한 도구를 선택
- 자동화 도구를 고려하여 프로젝트 일정 계획
- 프로젝트 초기에 테스트 엔지니어 투입 시기 계획

테스트 자동화 도구의 유형(?)

테스트 수행 단계별 테스트 자동화 도구(?)

결함 관리

결함 
소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것

결함 관리 프로세스
애플리케이션 테스트에서 발견된 결함을 처리

결함 상태 추적
테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 함

결함 추적 순서
결함이 발견되고 해결될 때까지의 과정
등록 -> 검토 -> 할당 -> 수정 -> 조치 보류 -> 해제

결함 분류
ㄱ. 시스템 결함 : 주로 애플리케이션이나 데이터베이스 처리에서 발생된 결함
ㄴ. 기능 결함 : 애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함
ㄷ. GUI 결함 : 화면 설계에서 발생된 결함
ㄹ. 문서 결함 : 기획자, 사용자, 개발자 간 의사소통 및 기록이 원활하지 않아 발생된 결함

결함 심각도
결함이 전체 시스템에 미치는 치명도를 High, Medium, Low로 나눈 것

결함 우선순위 
발견된 결함 처리에 대한 신속성을 나타내는 척도

결함 관리 도구

애플리케이션 성능 분석

애플리케이션 성능
사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도

성능 테스트 도구
애플리케이션의 성능을 테스트하기 위해 부하나 스트레스를 가해 성능 측정 지표를 점검하는 도구

시스템 모니터링 도구
애플리케이션 실행 중 시스템 자원의 사용량을 확인하고 분석하는 도구

애플리케이션 성능 개선

소스코드 최적화
나쁜 코드를 배제하고 클린 코드로 작성

소스 코드 최적화 유형
클래스 분할 배치, 느슨한 결합, 코딩 형식 준수, 좋은 이름 사용, 적절한 주석문 사용

모듈 간 공통 기능 및 데이터 인터페이스 확인

모듈 간 공통 기능 및 데이터 인터페이스의 개요
- 공통 기능 : 모듈에 공통적으로 제공되는 기능
- 데이터 인터페이스 : 모듈 간 교환되는 데이터가 저장될 파라미터

인터페이스 설계서
교환 데이터 및 관련 업무, 송수신 시스템 등에 대한 내용을 정리한 문서

일반적인 인터페이스 설계서
인터페이스 목록, 상세 데이터 명세, 기능의 세부 정보를 정의한 문서
ㄱ. 시스템 인터페이스 설계서 : 시스템 인터페이스 목록과 상세 데이터 명세를 정의
ㄴ. 상세 기능별 인터페이스 명세서 : 기능의 세부 인터페이스 정보 정의
ㄷ. 정적/도형 모형을 통한 인터페이스 설계서 : 시스템의 구성요소를 다이어그램으로 표현하여 만든 문서

모듈 연계를 위한 인터페이스 기능 식별

모듈 연계
모듈 간 데이터 교환을 위해 관계를 설정

EAI(Enterprise Application Integration)
기업 내 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
ㄱ. Point-to-Point 
- 애플리케이션끼리 1:1로 연결
- 변경 및 재사용이 어려움
ㄴ. Hub &Spoke - 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
- 확장 및 유지보수 용이
- 허브 장애 시 전체 시스템에 영향
ㄷ. Message Bus(ESB 방식)
- 애플리케이션 사이 미들웨어를 두어 처리
- 확장성이 뛰어나고 대용량 처리 가능
ㅁ. Hybrid - Hub &Spoke와 Message Bus의 혼합 방식
- 그룹 내에선 Hub &Spoke 방식을 그룹 간에는 Message Bus 방식 이용
- 데이터 병목 현상 최소화

ESB(Enterprise Service Bus)
애플리케이션 간 표준 기반 인터페이스를 제공하는 솔루션
- 애플리케이션보다는 서비스 중심의 통합을 지향
- 애플리케이션과의 결합도를 약하게 유지
- 관리 및 보안 유지가 쉽고 높은 수준의 품질 지원

모듈 간 인터페이스 데이터 표준 확인(?)
인터페이스 기능 구현 정의(?)
인터페이스 구현(?)
인터페이스 예외 처리(?)
인터페이스 보안(?)
연계 테스트(?)

인터페이스 구현 검증

인터페이스 구현 검증
인터페이스가 정상적으로 잘 작동하는지 확인하는 것

인터페이스 구현 검증 도구 
ㄱ. xUnit : Java, C++, .Net 등 다양한 언어를 지원
ㄴ. STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원
ㄷ. FitNesse : 웹 기반 테스트케이스 설계, 진행, 결과 확인 등을 지원
ㄹ. NTAF : FitNess의 협업 기능과 STAF의 재사용 및 확장성을 통합한 NHN의 프레임워크
ㅁ. Selenium : 다양한 브라우저 및 개발 언어 지원
ㅂ. watir : Ruby를 사용

인터페이스 구현 검증 확인
- 외부 시스템과 연계 모듈 동작 상태 확인
- 예상되는 결과값과 실제 검증 값이 동일한지 비교

인터페이스 구현 감시 확인
- 외부 시스템과 연결 모듈이 서비스를 제공하는 동안 정상적으로 동작하는지 확인

인터페이스 오류 확인 및 처리 보고서 작성(?)
```