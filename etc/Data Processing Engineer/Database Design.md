# Database Design
#Data Processing Engineer/Database Design

```
데이터베이스 구축 43 ~ 52

 데이터베이스 설계

데이터베이스 설계
: 사용자의 요구를 분석하여 그것에 맞게 설계하고 특정 

데이터베이스 설계 순서
:요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
ㄱ. 개념적 설계 : 개념 스키마, E-R 모델, 트랜잭션 모델링
ㄴ. 논리적 설계 : 논리 스키마 설계 /  트랜잭션 인터페이스 설계 / 관계형 DB - Table, 계층형 DB - Tree, 망형 DB - Graph
ㄷ. 물리적 설계 : 컴퓨터에 저장

데이터베이스 설계 시 고려사항
- 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장

데이터 모델의 개념

데이터 모델
현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형

데이터 모델의 구성 요소
개체(Entity), 속성(Attribute), 관계(Relation)

데이터 모델의 종류
개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
데이터 모델에 표시할 요소
ㄱ. 구조(Structure) : 개체 타입들 간의 관계, 데이터 구조 및 정적 성질 표현
ㄴ. 연산(Operation) : 저장된 데이터를 처리하는 작업에 대한 명세, DB를 조작하는 기본 도구
ㄷ. 제약 조건(Constraint) :  데이터의 논리적인 제약 조건

데이터 모델의 구성 요소

개체
데이터베이스의 표현하려는 정보
- 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 이루어짐
- 유일한 식별자에 의해 식별이 가능
- 개체(튜플)의 수를 카디널리티라고 함
- 개체 인스턴스 : 개체를 구성하고 있는 속성들이 값을 가져 하나의 개체를 나타내는 것

릴레이션 스키마와 인스턴스
ㄱ. 릴레이션
주로 테이블(Table)과 같은 의미로 사용되며, 데이터의 집합을 의미한다. 튜플(Tuple)과 어트리뷰트(Attribute)로 구성됨
ㄴ. 스키마
관계 데이터베이스의 릴레이션이 어떻게 구성되는지 어떤 정보를 담고 있는지에 대한 기본적인 구조를 정의
- 테이블에서 스키마는 첫 행인 헤더에 나타나며 데이터의 특징인 속성, 자료 타입 등의 정보를 담고 있음
ㄷ. 인스턴스
정의된 스키마에 따라 테이블에 실제로 저장되는 데이터의 집합
ㄹ. 튜플(=레코드(Record)=행(Row))
릴레이션을 구성하는 각각의 행
- 튜플의 수 = 카디널리티 = 기수
ㅁ. 도메인(Domain)
: 하나의 속성(Attribute)이 취할 수 있는 같은 타입의 원자 값들의 집합
ㅂ. 속성(Attribute)
: 릴레이션을 구성하는 각각의 열(DB의 가장 작은 논리 단위) - 데이터 베이스를 구성하는 가장 작은 논리적 단위
- 파일 구조상 데이터 항목 또는 데이터 필드에 해당
- 개체의 특성을 기술함
- 속성의 수 = 디그리(Degree) = 차수

속성의 분류
ㄱ. 기본키 속성(Primary Key Attribute) : 개체를 식별할 수 있는 속성 ex) 학번
ㄴ. 외래키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성
ㄷ. 일반 속성 : 개체에 포함되어 있지만 기본키, 외래키가 아닌 속성

관계

개체 간의 논리적인 연결
[개체 간 관계는 점선, 속성 간 관계는 실선으로 표현]

관계의 형태
- 1:1, 1:N, N:M 3가지 관계가 있음

식별 / 비식별 관계
- 식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키면서 동시에 기본인 것
- 비식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키이지만 기본키는 아닌 것
- 한 개체의 기본키를 다른 개체가 기본키로 사용하면 식별, 아니면 비식별

식별자

식별자
하나의 개체 내에서 각각의 인스턴스를 유일하게 구분 지을 수 있는 것

식별자의 분류
ㄱ. 대표성 여부 : 개체를 유일하게 식별할 수 있음
a. 주 식별자
- 개체를 대표하는 유일한 식별자 ex) 학번
- 주 식별자의 특징 : 유일성, 최소성, 불변성, 존재성
b.보조 식별자 : 주 식별자를 대신하여 개체를 식별할 수 있는 것 ex) 이름 or 학과 or 학년 등 유일하지 않은 것

ㄴ. 스스로 생성 여부
a. 내부 식별자 : 개체 내에서 스스로 만들어지는 식별자
b. 외부 식별자 : 다른 개체와의 관계에서 만들어지는 식별자
ㄷ. 단일 속성 여부
 a. 단일 식별자 : 주 식별자가 한 가지 속성으로 구성된 식별자
 b. 복합 식별자 : 주 식별자가 두 개 이상의 속성으로 구성된 식별자

ㄹ. 대체 여부
a. 원조 식별자(=본질 식별자) : 업무에 의해 만들어지는 가공되지 않은 원래의 식별자
b. 대리 식별자 : 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자

 E-R(개체-관계) 모델

E-R 모델 (Entity, Attribute, Relationship)
: E-R 모델은 개념적 데이터 모델의 가장 대표적인 모델

E-R 다이어그램
: E-R 모델의 기본 아이디어를 쉽게 기호를 사용하여 시각적으로 표현한 것
- 표기법에는 피터 첸 표기법, 정보 공학 표기법 등이 있음
ㄱ. 피터 첸 표기법
a. 사각형 : 개체 타입
b. 마름모 : 관계 타입
c. 타원 : 속성 타입
d. 이중 타원 : 복합 속성
e. 밑줄 타원 : 기본키 속성
f. 복수 타원 : 복합 속성
g. 관계 : 1:1, 1:N, N:M 같은 관계에 대한 대응 수
ㄴ. 정보 공학 표기법
- 관계 표시 기호
a. | : 1 
b. O : 0
c. <: N

관계형 데이터베이스의 구조

관계형 데이터베이스
: 가장 많이 사용되는 데이터베이스로서 흔히 행(Row)과 열(Column)로 표현되는 테이블간의 관계를 나타낼 때 사용되며, 이렇게 표현된 데이터베이스는 SQL을 통하여 관리 및 접근한다.

RDB 종류
- Oracle, MySQL(Oracle) / MS-SQL(Microsoft) / DB2, Infomix(IBM) / Maria DB(Sun Microsystems) / Derby(Apache) / SQLite(Opensource)

관계형 데이터베이스의 제약 조건

Key의 개념
key는 데이터베이스에서 조건에 맞는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 속성

Key의 종류
ㄱ. 후보키
기본키로 사용할 수 있는 속성
- 유일성과 최소성의 성질을 만족
ㄴ. 기본키
: 후보 키 중에서 선정된 Main Key로 중복된 값을 가질 수 없음
- 후보 키의 부분집합
- NULL 값을 가질 수 없음(=개체 무결성)
ㄷ. 대체키
: 후보 키가 둘 이상일 때 기본키를 제외한 나머지 후보키
ㄹ. 슈퍼키
한 가지 속성일 땐 Key가 될 수 없지만 여러 속성이 뭉쳐서 
Key의 속성을 가짐
-유일성의 성질을 만족
ㅁ. 외래키
: 다른 릴레이션의 기본 키를 참조한 것
- 외래 키의 값은 참조한 릴레이션의 기본키 값과 동일해야 함(=참조 무결성)

정규화

정규화
관계형 데이터베이스에서 정확성을 더욱 유지하기 위해 스키마를 쪼개는 과정
- 데이터베이스의 논리적 설계 단계에서 수행

정규화의 목적
- 데이터 구조의 안정성 및 무결성을 유지
- 이상의 발생을 방지 및 자료 저장 공간의 최소화

이상(Anomaly) - 사용자의 의도와는 상관없이 데이터가 삽입, 삭제, 갱신되는 현상

정규화 과정
: 1NF -> 2NF -> 3NF -> BCNF -> 4NF -> 5NF
ㄱ. 1NF(제1 정규형)
: 릴레이션에 속한 모든 값들이 원자 값으로만 구성
ㄴ. 2NF(제2 정규형)
기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족
a. 완전 함수적 종속 : 기본키에 의해서 속성이 결정
b. 부분 함수적 종속 : 기본키의 일부에 의해 속성이 결정
ㄷ. 3NF(제3 정규형)
기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음
- 이행적 종속 : A → B, B → C 일 때 A → C를 만족하는 관계
- BCNF(Boyce-Codd정규형) : 결정자가 모두 후보키가 되도록 테이블 분해
ㄹ. 4NF(제4 정규형)
릴레이션에 다치 종속이 성립하는 경우 모든 속성이 함수적 종속 관계를 만족
ㅁ. 5NF(제5 정규형)
모든 조인 종속이 후보키를 통해서만 성립

정규화
정규화된 데이터를 다시 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위

반정규화

반정규화
정규화된 데이터를 다시 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위해
- 과도한 정규화로 성능이 떨어졌을 때 실행

반정규화의 종류
ㄱ. 테이블 통합
하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
ㄴ. 테이블 분할
테이블을 수평 또는 수직으로 분할
ㄷ. 중복 테이블 추가
여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 수행
ㄹ. 중복 속성 추가
조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가

시스템 카탈로그 

시스템 카탈로그
시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 데이터 사전(Data Dictionary)이라고도 함

시스템 카탈로그 저장 정보
: 시스템 카탈로그에 저장되는 정보를 메타 데이터라고 함
- 메타 데이터 : 데이터에 대한 설명. 메타 데이터가 모이면 데이터 사전이 됨

메타 데이터의 유형
ㄱ. 데이터 베이스 객체 정보 : Table, Index, View 등의 구조 및 통계 정보
ㄴ. 사용자 정보
ㄷ. 테이블의 무결성 제약 조건 정보
ㄹ. 함수, 프로시저, 트리거 등에 대한 정보

시스템 카탈로그의 특징
- 시스템 테이블로 구성되어 있어 SQL문으로 검색해 볼 수 있음
- DML(INSERT, DELETE, UPDATE) 문으로 갱신이 불가능

사전 조사 분석

물리 데이터베이스 설계
논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변화하는 과정

데이터베이스 설계 순서
요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현

물리적 설계 단계에서 수행해야 할 것
ㄱ. 저장 레코드의 양식 설계
ㄴ. 레코드 집중의 분석 및 설계
ㄷ. 접근 경로 설계
- 물리적 데이터베이스 구조는 여러 가지 타입의 저장 레코드 집합이라는 면에서 단순한 파일과 다름

물리적 설계 옵션
ㄱ. 반응시간 : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과 시간
ㄴ. 공간 활용도 : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장 공간의 양
ㄷ. 트랜잭션 처리량 : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수

데이터 명명 규칙 파악
- 물리 데이터 모델에 적용해야하는 규칙

시스템 자원 파악
: 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소하드웨어 자원, 운영체제 및 DBMS의 버전, DBMS 파라미터 
정보 등으로 구분

데이터베이스 관리 요소 파악
: 데이터베이스 운영과 관련된 관리요소를 파악
- 데이터베이스 관리 요소를 파악한 후 이를 기반으로 시스템 조사 분석서를 작성
- 시스템 조사 분석서를 기반으로 다음과 같은 요소들을 파악
ㄱ. 데이터베이스 구조 : 데이터베이스 구조에 따라 문제 발생 시 대응 방법이 다름
ㄴ. 이중화 구성 : 문제 발생에 대비하여 동일한 데이터베이스를 복제하여 관리
ㄷ. 분산 데이터베이스 : 물리적인 피해에 데이터 유실을 최소화할 수 있고 장애로 인한 데이터 유실 복구에 효과적
ㄹ. 접근&제어 통제 : 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 빈번하게 발생
ㅁ. DB암호화 : 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 함

 데이터베이스 저장 공간 설계

테이블
데이터베이스의 가장 기본적인 객체로써 행(Row)과 열(Column)으로 구성됨
- 논리 설계 단계의 개체(Entity)에 대응하는 객체
- 종류에는 일반 테이블, 클러스터 인덱스 테이블, 파티셔닝테이블, 외부 테이블, 임시 테이블 등이 있음

일반 테이블
- 현재 사용되는 대부분의 DBMS(DataBase Management System)에서 표준 테이블로 사용되는 테이블

클러스터드 인덱스 테이블
: 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축

파티셔닝 테이블
: 대용량의 테이블을 작은 논리적인 단위인 파티션으로 나눈 테이블
- 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등 역효과를 초래할 수 있음
- 방식에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉨
ㄱ. 범위 분할 : 지정한 열의 값을 기준으로 분할
ㄴ. 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
ㄷ. 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

외부 테이블
데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로 데이터베이스 내에 객체로 존재

임시 테이블
트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
- 절차적인 처리를 위해 임시로 사용
- 저장된 데이터는 트랜잭션이 종료되면 삭제

컬럼
테이블의 열을 구성하는 요소로 데이터타입과 길이 등으로 정의

테이블스페이스
: 테이블이 저장되는 논리적인 영역으로 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있음

트랜잭션 및 CRUD 분석

트랜잭션
데이터베이스의 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 작업 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미

트랜잭션의 특성
ㄱ. 원자성(Atomicity)
a. 데이터베이스에 반영되도록 완전히 완료 아니면 전혀 반영되지 않도록 복구되어야 함
b. 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
ㄴ. 일관성(Consistency)
a. 문법을 일괄적으로 맞춰야 함
b. 트랜잭션을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환
c. 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후가 상태가 같아야 함
ㄷ. 독립성(Isolation)
a. 하나의 트랜잭션 연산중에는 다른 트랜잭션이 관여하면 안 됨
b. 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
ㄹ. 지속성(Durability)
a. 성공적으로 완료된 트랜잭션의 결과는 영구적으로 유지, 반영되어야 함

CRUD 분석
- 데이터베이스의 테이블에 변화를 주는 트랜잭션 연산 중 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 연산
에 대해 CRUD 매트릭스를 작성하여 분석하는 것

CRUD 매트릭스
2차원 표로 행에는 프로세스 열에는 테이블을 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시
하는 업무 프로세스와 데이터 간 상관 분석표

트랜잭션 분석
 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하고 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB용량을 산정, DB 구조를 최적화하는 것

트랜잭션 분석서
- 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
- 구성 요소에는 단위 프로세스, CRUD 연산, 테이블 명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등

인덱스 설계 

인덱스
데이터 레코드를 빠르게 접근하기 위한 키값, 포인터 쌍으로 구성되는 데이터 구조

TABLE SCAN 
데이터가 나올 때까지 모든 레코드를 순차적으로 읽는 것
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스
의 개수를 최소로 하는 것이 효율적
- 클러스터드 인덱스 : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 넌클러스터드 인덱스 : 인덱스의 키값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식

트리 기반 인덱스
인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
ㄱ. B 트리 인덱스
: 일반적으로 사용하는 인덱스 방식
- 루트 노드에서 하위 노드로 키값의 크기를 비교하면서 데이터를 검색
- 모든 리프 노드의 레벨은 같음
ㄴ. B+ 트리 인덱스
: 단말 노드가 아닌 노드로 구성된 인덱스 - 세트와 단말 노드로만 구성된 순차 세트로 구분
- 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공
- 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
- 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리 가능

비트맵 인덱스
인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법

함수 기반 인덱스
: 컬럼의 값 대신 컬럼의 특정 함수나 수식을 적용하여 산출된 값을 사용
- B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
- 데이터를 입력하거나 수정할 때 함수를 적용하기 때문에 부하가 발생할 수 있음
- 사용자 정의 함수를 사용했을 경우 시스템 함수보다 부하가 더 크다
- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용

비트맵 조인 인덱스
다수의 조인된 객체로 구성된 인덱스

도메인 인덱스
개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로 확장형 인덱스라고도 함

인덱스 설계 순서
인덱스의 대상 테이블이나 컬럼 등을 선정 → 인덱스의 효율성을 검토하여 인덱스 최적화 수행 →  인덱스 정의서 작성

인덱스 테이블 선정 기준
- MULTI BLOCK READ 수에 따라 판단

MULTI BLOCK READ
테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수
- 랜덤 액세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블

인덱스 설계 시 고려사항
- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음
- 인덱스를 지나치게 만들면 오버헤드 발생
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생
- 인덱스를 만들면 추가적인 저장 공간 필요
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계

뷰 설계

뷰(View)
사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는  가상 테이블
- 물리적으로 존재하지는 않지만 사용자에게는 있는 것처럼 간주됨
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
- 조인문의 최소화로 사용자 편의성을 최대화함

뷰의 특징 
기본 테이블과 같은 형태의 구조를 사용하고 조작도 기본 테이블과 거의 같음
- 가상테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 논리적 독립성을 제공할 수 있음
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
- 뷰를 통해서만 데이터에 접근하게 되면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제 시 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제

뷰의 장단점
ㄱ. 장점
- 논리적 데이터 독립성 제공
- 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구를 지원
- 사용자의 데이터 관리가 용이
- 접근 제어를 통한 자동 보안 제공
ㄴ. 단점
- 독립적인 인덱스를 가질 수 없음
- 뷰의 정의 변경 불가
- 뷰로 구성된 내용에 대해 INSERT, DELETE, UPDATE 연산에 제약이 따름

뷰 설계 순서
- 대상 테이블 선정 → 대상 컬럼 선정 → 정의서 작성

뷰 설계 시 고려사항
- 테이블 구조가 단순화될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
- 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시
- 데이터의 보안을 유지하며 설계

클러스터의 설계

클러스터
: 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 데이터 블록에 저장하는 물리적 저장 방법

클러스터의 특징
: 데이터 조회 속도는 향상시키지만 데이터 입력 수정 삭제에 대한 성능은 저하시킴
- 데이터의 분포도가 넓을수록 유리
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 지양
- 파티셔닝 된 테이블에는 적용할 수 없음

클러스터 대상 테이블
- 분포도가 넓은 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블
- ORDER BY, GROUP BY, UNION이 빈번한 테이블
```