# Database Design
#Data Processing Engineer/Database Design

```
데이터베이스 구축

 데이터베이스 설계

데이터베이스 설계
: 사용자의 요구를 분석하여 그것에 맞게 설계하고 특정 

데이터베이스 설계 순서
:요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
ㄱ. 개념적 설계 : 개념 스키마, E-R 모델, 트랜잭션 모델링
ㄴ. 논리적 설계 : 논리 스키마 설계 /  트랜잭션 인터페이스 설계 / 관계형 DB - Table, 계층형 DB - Tree, 망형 DB - Graph
ㄷ. 물리적 설계 : 컴퓨터에 저장

데이터베이스 설계 시 고려사항
- 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장

데이터 모델의 개념

데이터 모델
현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형

데이터 모델의 구성 요소
개체(Entity), 속성(Attribute), 관계(Relation)

데이터 모델의 종류
개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
데이터 모델에 표시할 요소
ㄱ. 구조(Structure) : 개체 타입들 간의 관계, 데이터 구조 및 정적 성질 표현
ㄴ. 연산(Operation) : 저장된 데이터를 처리하는 작업에 대한 명세, DB를 조작하는 기본 도구
ㄷ. 제약 조건(Constraint) :  데이터의 논리적인 제약 조건

데이터 모델의 구성 요소

개체
데이터베이스의 표현하려는 정보
- 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 이루어짐
- 유일한 식별자에 의해 식별이 가능
- 개체(튜플)의 수를 카디널리티라고 함
- 개체 인스턴스 : 개체를 구성하고 있는 속성들이 값을 가져 하나의 개체를 나타내는 것

릴레이션 스키마와 인스턴스
ㄱ. 릴레이션
주로 테이블(Table)과 같은 의미로 사용되며, 데이터의 집합을 의미한다. 튜플(Tuple)과 어트리뷰트(Attribute)로 구성됨
ㄴ. 스키마
관계 데이터베이스의 릴레이션이 어떻게 구성되는지 어떤 정보를 담고 있는지에 대한 기본적인 구조를 정의
- 테이블에서 스키마는 첫 행인 헤더에 나타나며 데이터의 특징인 속성, 자료 타입 등의 정보를 담고 있음
ㄷ. 인스턴스
정의된 스키마에 따라 테이블에 실제로 저장되는 데이터의 집합
ㄹ. 튜플(=레코드(Record)=행(Row))
릴레이션을 구성하는 각각의 행
- 튜플의 수 = 카디널리티 = 기수
ㅁ. 도메인(Domain)
: 하나의 속성(Attribute)이 취할 수 있는 같은 타입의 원자 값들의 집합
ㅂ. 속성(Attribute)
: 릴레이션을 구성하는 각각의 열(DB의 가장 작은 논리 단위) - 데이터 베이스를 구성하는 가장 작은 논리적 단위
- 파일 구조상 데이터 항목 또는 데이터 필드에 해당
- 개체의 특성을 기술함
- 속성의 수 = 디그리(Degree) = 차수

속성의 분류
ㄱ. 기본키 속성(Primary Key Attribute) : 개체를 식별할 수 있는 속성 ex) 학번
ㄴ. 외래키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성
ㄷ. 일반 속성 : 개체에 포함되어 있지만 기본키, 외래키가 아닌 속성

관계

개체 간의 논리적인 연결
[개체 간 관계는 점선, 속성 간 관계는 실선으로 표현]

관계의 형태
- 1:1, 1:N, N:M 3가지 관계가 있음

식별 / 비식별 관계
- 식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키면서 동시에 기본인 것
- 비식별 관계 : A,B 개체 간의 관계에서 A 개체의 기본키가 B 개체의 외래키이지만 기본키는 아닌 것
- 한 개체의 기본키를 다른 개체가 기본키로 사용하면 식별, 아니면 비식별

식별자

식별자
하나의 개체 내에서 각각의 인스턴스를 유일하게 구분 지을 수 있는 것

식별자의 분류
ㄱ. 대표성 여부 : 개체를 유일하게 식별할 수 있음
a. 주 식별자
- 개체를 대표하는 유일한 식별자 ex) 학번
- 주 식별자의 특징 : 유일성, 최소성, 불변성, 존재성
b.보조 식별자 : 주 식별자를 대신하여 개체를 식별할 수 있는 것 ex) 이름 or 학과 or 학년 등 유일하지 않은 것

ㄴ. 스스로 생성 여부
a. 내부 식별자 : 개체 내에서 스스로 만들어지는 식별자
b. 외부 식별자 : 다른 개체와의 관계에서 만들어지는 식별자
ㄷ. 단일 속성 여부
 a. 단일 식별자 : 주 식별자가 한 가지 속성으로 구성된 식별자
 b. 복합 식별자 : 주 식별자가 두 개 이상의 속성으로 구성된 식별자

ㄹ. 대체 여부
a. 원조 식별자(=본질 식별자) : 업무에 의해 만들어지는 가공되지 않은 원래의 식별자
b. 대리 식별자 : 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자

 E-R(개체-관계) 모델

E-R 모델 (Entity, Attribute, Relationship)
: E-R 모델은 개념적 데이터 모델의 가장 대표적인 모델

E-R 다이어그램
: E-R 모델의 기본 아이디어를 쉽게 기호를 사용하여 시각적으로 표현한 것
- 표기법에는 피터 첸 표기법, 정보 공학 표기법 등이 있음
ㄱ. 피터 첸 표기법
a. 사각형 : 개체 타입
b. 마름모 : 관계 타입
c. 타원 : 속성 타입
d. 이중 타원 : 복합 속성
e. 밑줄 타원 : 기본키 속성
f. 복수 타원 : 복합 속성
g. 관계 : 1:1, 1:N, N:M 같은 관계에 대한 대응 수
ㄴ. 정보 공학 표기법
- 관계 표시 기호
a. | : 1 
b. O : 0
c. <: N

관계형 데이터베이스의 구조

관계형 데이터베이스
: 가장 많이 사용되는 데이터베이스로서 흔히 행(Row)과 열(Column)로 표현되는 테이블간의 관계를 나타낼 때 사용되며, 이렇게 표현된 데이터베이스는 SQL을 통하여 관리 및 접근한다.

RDB 종류
- Oracle, MySQL(Oracle) / MS-SQL(Microsoft) / DB2, Infomix(IBM) / Maria DB(Sun Microsystems) / Derby(Apache) / SQLite(Opensource)

관계형 데이터베이스의 제약 조건

Key의 개념
key는 데이터베이스에서 조건에 맞는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 속성

Key의 종류
ㄱ. 후보키
기본키로 사용할 수 있는 속성
- 유일성과 최소성의 성질을 만족
ㄴ. 기본키
: 후보 키 중에서 선정된 Main Key로 중복된 값을 가질 수 없음
- 후보 키의 부분집합
- NULL 값을 가질 수 없음(=개체 무결성)
ㄷ. 대체키
: 후보 키가 둘 이상일 때 기본키를 제외한 나머지 후보키
ㄹ. 슈퍼키
한 가지 속성일 땐 Key가 될 수 없지만 여러 속성이 뭉쳐서 
Key의 속성을 가짐
-유일성의 성질을 만족
ㅁ. 외래키
: 다른 릴레이션의 기본 키를 참조한 것
- 외래 키의 값은 참조한 릴레이션의 기본키 값과 동일해야 함(=참조 무결성)

정규화

정규화
관계형 데이터베이스에서 정확성을 더욱 유지하기 위해 스키마를 쪼개는 과정
- 데이터베이스의 논리적 설계 단계에서 수행

정규화의 목적
- 데이터 구조의 안정성 및 무결성을 유지
- 이상의 발생을 방지 및 자료 저장 공간의 최소화

이상(Anomaly) - 사용자의 의도와는 상관없이 데이터가 삽입, 삭제, 갱신되는 현상

정규화 과정
: 1NF -> 2NF -> 3NF -> BCNF -> 4NF -> 5NF
ㄱ. 1NF(제1 정규형)
: 릴레이션에 속한 모든 값들이 원자 값으로만 구성
ㄴ. 2NF(제2 정규형)
기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족
a. 완전 함수적 종속 : 기본키에 의해서 속성이 결정
b. 부분 함수적 종속 : 기본키의 일부에 의해 속성이 결정
ㄷ. 3NF(제3 정규형)
기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음
- 이행적 종속 : A → B, B → C 일 때 A → C를 만족하는 관계
- BCNF(Boyce-Codd정규형) : 결정자가 모두 후보키가 되도록 테이블 분해
ㄹ. 4NF(제4 정규형)
릴레이션에 다치 종속이 성립하는 경우 모든 속성이 함수적 종속 관계를 만족
ㅁ. 5NF(제5 정규형)
모든 조인 종속이 후보키를 통해서만 성립

정규화
정규화된 데이터를 다시 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위

반정규화

반정규화
정규화된 데이터를 다시 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위해
- 과도한 정규화로 성능이 떨어졌을 때 실행

반정규화의 종류
ㄱ. 테이블 통합
하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
ㄴ. 테이블 분할
테이블을 수평 또는 수직으로 분할
ㄷ. 중복 테이블 추가
여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 수행
ㄹ. 중복 속성 추가
조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가

시스템 카탈로그 

시스템 카탈로그
시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 데이터 사전(Data Dictionary)이라고도 함

시스템 카탈로그 저장 정보
: 시스템 카탈로그에 저장되는 정보를 메타 데이터라고 함
- 메타 데이터 : 데이터에 대한 설명. 메타 데이터가 모이면 데이터 사전이 됨

메타 데이터의 유형
ㄱ. 데이터 베이스 객체 정보 : Table, Index, View 등의 구조 및 통계 정보
ㄴ. 사용자 정보
ㄷ. 테이블의 무결성 제약 조건 정보
ㄹ. 함수, 프로시저, 트리거 등에 대한 정보

시스템 카탈로그의 특징
- 시스템 테이블로 구성되어 있어 SQL문으로 검색해 볼 수 있음
- DML(INSERT, DELETE, UPDATE) 문으로 갱신이 불가능

사전 조사 분석

물리 데이터베이스 설계
논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변화하는 과정

데이터베이스 설계 순서
요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현

물리적 설계 단계에서 수행해야 할 것
ㄱ. 저장 레코드의 양식 설계
ㄴ. 레코드 집중의 분석 및 설계
ㄷ. 접근 경로 설계
- 물리적 데이터베이스 구조는 여러 가지 타입의 저장 레코드 집합이라는 면에서 단순한 파일과 다름

물리적 설계 옵션
ㄱ. 반응시간 : 트랜잭션 수행을 요구한 시점부터 처리 결과를 얻을 때까지의 경과 시간
ㄴ. 공간 활용도 : 데이터베이스 파일과 액세스 경로 구조에 의해 사용되는 저장 공간의 양
ㄷ. 트랜잭션 처리량 : 단위시간 동안 데이터베이스 시스템에 의해 처리될 수 있는 트랜잭션의 평균 개수

데이터 명명 규칙 파악
- 물리 데이터 모델에 적용해야하는 규칙

시스템 자원 파악
: 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소하드웨어 자원, 운영체제 및 DBMS의 버전, DBMS 파라미터 
정보 등으로 구분

데이터베이스 관리 요소 파악
: 데이터베이스 운영과 관련된 관리요소를 파악
- 데이터베이스 관리 요소를 파악한 후 이를 기반으로 시스템 조사 분석서를 작성
- 시스템 조사 분석서를 기반으로 다음과 같은 요소들을 파악
ㄱ. 데이터베이스 구조 : 데이터베이스 구조에 따라 문제 발생 시 대응 방법이 다름
ㄴ. 이중화 구성 : 문제 발생에 대비하여 동일한 데이터베이스를 복제하여 관리
ㄷ. 분산 데이터베이스 : 물리적인 피해에 데이터 유실을 최소화할 수 있고 장애로 인한 데이터 유실 복구에 효과적
ㄹ. 접근&제어 통제 : 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 빈번하게 발생
ㅁ. DB암호화 : 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 함

 데이터베이스 저장 공간 설계

테이블
데이터베이스의 가장 기본적인 객체로써 행(Row)과 열(Column)으로 구성됨
- 논리 설계 단계의 개체(Entity)에 대응하는 객체
- 종류에는 일반 테이블, 클러스터 인덱스 테이블, 파티셔닝테이블, 외부 테이블, 임시 테이블 등이 있음

일반 테이블
- 현재 사용되는 대부분의 DBMS(DataBase Management System)에서 표준 테이블로 사용되는 테이블

클러스터드 인덱스 테이블
: 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
- 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축

파티셔닝 테이블
: 대용량의 테이블을 작은 논리적인 단위인 파티션으로 나눈 테이블
- 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등 역효과를 초래할 수 있음
- 방식에 따라 범위 분할, 해시 분할, 조합 분할 등으로 나뉨
ㄱ. 범위 분할 : 지정한 열의 값을 기준으로 분할
ㄴ. 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
ㄷ. 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

외부 테이블
데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로 데이터베이스 내에 객체로 존재

임시 테이블
트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
- 절차적인 처리를 위해 임시로 사용
- 저장된 데이터는 트랜잭션이 종료되면 삭제

컬럼
테이블의 열을 구성하는 요소로 데이터타입과 길이 등으로 정의

테이블스페이스
: 테이블이 저장되는 논리적인 영역으로 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있음

트랜잭션 및 CRUD 분석

트랜잭션
데이터베이스의 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 작업 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미

트랜잭션의 특성
ㄱ. 원자성(Atomicity)
a. 데이터베이스에 반영되도록 완전히 완료 아니면 전혀 반영되지 않도록 복구되어야 함
b. 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
ㄴ. 일관성(Consistency)
a. 문법을 일괄적으로 맞춰야 함
b. 트랜잭션을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환
c. 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후가 상태가 같아야 함
ㄷ. 독립성(Isolation)
a. 하나의 트랜잭션 연산중에는 다른 트랜잭션이 관여하면 안 됨
b. 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
ㄹ. 지속성(Durability)
a. 성공적으로 완료된 트랜잭션의 결과는 영구적으로 유지, 반영되어야 함

CRUD 분석
- 데이터베이스의 테이블에 변화를 주는 트랜잭션 연산 중 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 연산
에 대해 CRUD 매트릭스를 작성하여 분석하는 것

CRUD 매트릭스
2차원 표로 행에는 프로세스 열에는 테이블을 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시
하는 업무 프로세스와 데이터 간 상관 분석표

트랜잭션 분석
 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하고 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB용량을 산정, DB 구조를 최적화하는 것

트랜잭션 분석서
- 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
- 구성 요소에는 단위 프로세스, CRUD 연산, 테이블 명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등

인덱스 설계 

인덱스
데이터 레코드를 빠르게 접근하기 위한 키값, 포인터 쌍으로 구성되는 데이터 구조

TABLE SCAN 
데이터가 나올 때까지 모든 레코드를 순차적으로 읽는 것
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스
의 개수를 최소로 하는 것이 효율적
- 클러스터드 인덱스 : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 넌클러스터드 인덱스 : 인덱스의 키값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식

트리 기반 인덱스
인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
ㄱ. B 트리 인덱스
: 일반적으로 사용하는 인덱스 방식
- 루트 노드에서 하위 노드로 키값의 크기를 비교하면서 데이터를 검색
- 모든 리프 노드의 레벨은 같음
ㄴ. B+ 트리 인덱스
: 단말 노드가 아닌 노드로 구성된 인덱스 - 세트와 단말 노드로만 구성된 순차 세트로 구분
- 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공
- 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
- 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리 가능

비트맵 인덱스
인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법

함수 기반 인덱스
: 컬럼의 값 대신 컬럼의 특정 함수나 수식을 적용하여 산출된 값을 사용
- B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
- 데이터를 입력하거나 수정할 때 함수를 적용하기 때문에 부하가 발생할 수 있음
- 사용자 정의 함수를 사용했을 경우 시스템 함수보다 부하가 더 크다
- 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용

비트맵 조인 인덱스
다수의 조인된 객체로 구성된 인덱스

도메인 인덱스
개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로 확장형 인덱스라고도 함

인덱스 설계 순서
인덱스의 대상 테이블이나 컬럼 등을 선정 → 인덱스의 효율성을 검토하여 인덱스 최적화 수행 →  인덱스 정의서 작성

인덱스 테이블 선정 기준
- MULTI BLOCK READ 수에 따라 판단

MULTI BLOCK READ
테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수
- 랜덤 액세스가 빈번한 테이블
- 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
- 다른 테이블과 순차적 조인이 발생되는 테이블

인덱스 설계 시 고려사항
- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음
- 인덱스를 지나치게 만들면 오버헤드 발생
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생
- 인덱스를 만들면 추가적인 저장 공간 필요
- 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계

뷰 설계

뷰(View)
사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는  가상 테이블
- 물리적으로 존재하지는 않지만 사용자에게는 있는 것처럼 간주됨
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
- 조인문의 최소화로 사용자 편의성을 최대화함

뷰의 특징 
기본 테이블과 같은 형태의 구조를 사용하고 조작도 기본 테이블과 거의 같음
- 가상테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 논리적 독립성을 제공할 수 있음
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
- 뷰를 통해서만 데이터에 접근하게 되면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제 시 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제

뷰의 장단점
ㄱ. 장점
- 논리적 데이터 독립성 제공
- 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구를 지원
- 사용자의 데이터 관리가 용이
- 접근 제어를 통한 자동 보안 제공
ㄴ. 단점
- 독립적인 인덱스를 가질 수 없음
- 뷰의 정의 변경 불가
- 뷰로 구성된 내용에 대해 INSERT, DELETE, UPDATE 연산에 제약이 따름

뷰 설계 순서
- 대상 테이블 선정 → 대상 컬럼 선정 → 정의서 작성

뷰 설계 시 고려사항
- 테이블 구조가 단순화될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
- 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시
- 데이터의 보안을 유지하며 설계

클러스터의 설계

클러스터
: 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 데이터 블록에 저장하는 물리적 저장 방법

클러스터의 특징
: 데이터 조회 속도는 향상시키지만 데이터 입력 수정 삭제에 대한 성능은 저하시킴
- 데이터의 분포도가 넓을수록 유리
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 지양
- 파티셔닝 된 테이블에는 적용할 수 없음

클러스터 대상 테이블
- 분포도가 넓은 테이블
- 입력, 수정, 삭제가 자주 발생하지 않는 테이블
- 자주 조인되어 사용되는 테이블
- ORDER BY, GROUP BY, UNION이 빈번한 테이블
```

```
파티션 설계

파티션
대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것

파티션의 장단점
ㄱ. 장점
- 데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상
- 데이터가 분산되어 저장되므로 디스크 성능 향상
- 파티션별로 백업 및 복구를 수행하므로 속도 향상
- 시스템 장애 시 데이터 손상 정도 최소화
- 데이터 가용성 향상
- 파티션 단위로 입출력 분산
ㄴ. 단점
- 하나의 테이블을 세분화하여 관리하기 때문에 세심한 관리가 요구됨
- 테이블 간 조인에 대한 비용이 증가
- 용량이 작은 테이블에 파티셔닝을 수행하면 성능이 저하됨

파티션의 종류
ㄱ. 범위 분할 : 지정한 열의 값을 기준으로 분할
ㄴ. 해시 분할 : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
ㄷ. 조합 분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

파티션 키 선정 시 고려사항
: 파티션 키는 테이블 접근 유형에 따라 파티셔닝이 이루어지도록 선정
- 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성 
주기와 소멸 주기를 일치시켜야 함
- 매일 생성되는 날짜 컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 이동이 없는 컬럼, I/O 병목을 줄일 수 있는 데이
터 분포가 양호한 컬럼 등을 파티션 키로 선정

인덱스 파티션
: 파티션 된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것
ㄱ. 파티션 된 테이블의 종속 여부에 따른 구분
- Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1:1 대응되도록 파티셔닝 함
- Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝 함
- Local Partitioned Index가 Global 보다 관리하기 용이함
ㄴ. 인덱스 파티션 키 컬럼의 위치에 따른 구분
- Prefixed Partitioned Index : 인덱스 파티션 키와 인덱스 첫 번째 컬럼이 같음
- Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다름

데이터베이스 용량 설계

데이터베이스 용량 설계
 데이터가 테이블에 저장될 공간을 정의
- 테이블에 저장할 데이터양, 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영

데이터베이스 용량 설계의 목적
 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높임
- 디스크의 입출력 부하를 분산시키고 채널의 병목현상 최소화
- 디스크에 대한 입출력 경합이 최소화되도록 설계함으로써 데이터 접근성이 향상
- 데이터베이스에 생성되는 오브젝트의 익스텐트 발생을 최소화하여 성능을 향상
- 테이블과 인덱스에 적합한 저장 옵션을 지정

데이터 접근성을 향상시키는 설계 방법
ㄱ. 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리하여 구성
ㄴ. 테이블스페이스와 임시 테이블스페이스를 분리하여 구성
ㄷ. 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

데이터베이스 용량 분석 절차
- 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량 분석
- 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정
- 테이블과 인덱스의 테이블스페이스 용량을 산정
- 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량 산정

75. 분산 데이터베이스 설계

분산 데이터베이스
논리적인 하나의 시스템이지만 물리적으로는 네트워크로 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스
- 데이터베이스를 네트워크를 이용해 나눠놓은 것

분산 데이터베이스의 구성 요소
- 분산 처리기 : 지리적으로 분산되어 있는 컴퓨터 시스템
- 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이스
- 통신 네트워크 : 분산 처리기들을 네트워크로 연결하여 하나의 시스템처럼 동작할 수 있도록 하는 통신 네트워크

분산 데이터베이스 설계 시 고려사항
- 작업 부하의 노드별 분산 정책
- 지역의 자치성 보장 정책
- 데이터의 일관성 정책
- 사이트나 회선의 고장으로부터의 회복 기능
- 통신 네트워크를 통한 원격 접속 기능

분산 데이터베이스의 목표
ㄱ. 위치 투명성 : 접근하려는 데이터베이스의 실제 위치를 알 필요 없이 논리적인 명칭만으로 접근 가능
ㄴ. 중복 투명성 : 동일 데이터가 여러 곳에 중복되어 있어도 사용자는 하나의 데이터만 존재하는 것처럼 사용 가능
ㄷ. 병행 투명성 : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음
ㄹ. 장애 투명성 : 트랜잭션, DBMS, 네트워크, 컴퓨터 등 장애에도 트랜잭션을 정확하게 처리
ㅁ. 투명성 : 사실 존재 여부를 염두에 두지 않아도 되는 성질

분산 데이터베이스의 특징
ㄱ. 장점
- 지역 자치성이 높음
- 자료의 공유성 향상
- 분산 제어 가능
- 시스템 성능 향상
- 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
- 효용성과 융통성이 높음
- 신뢰성 및 가용성이 좋음
- 점진적 시스템 용량 확장 용이
ㄴ. 단점
- DBMS가 수행할 기능이 복잡
- DB 설계가 어려움
- 소프트웨어 개발 비용 증가
- 처리 비용 증가
- 잠재적 오류 증가

분산 데이터베이스 설계
- 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하는 것이 목적
- 전역 관계망을 논리적 측면에서 소규모 단위로 분할, 분할
된 결과를 복수의 노드에 할당
- 분산 설계 방법에는 테이블 위치 분산, 분할, 할당이 있음

ㄱ. 테이블 위치 분산
- 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치
- 테이블의 구조를 변경시키지 않고 다른 데이터베이스의 테이블과 중복되지 않게 배치

ㄴ. 분할
- 테이블의 데이터를 분할하여 분산
a. 분할 규칙
- 완전성 : 전체 데이터를 대상으로 분할해야 함
- 재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성이 가능해야 함
- 상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 함
b. 분할 방법
- 수평 분할 : 행 단위로 분할
- 수직 분할 : 속성 단위로 분할

ㄷ. 할당
동일한 분할을 여러 개의 서버에 생성하는 분산 방법
a.비중복 할당 방식
: 최적의 노드를 선택해서 분산 데이터베이스의 단일 노드에서만 분할이 존재
b. 중복 할당 방식
: 동일한 테이블을 다른 서버에 복제하는 방식

데이터베이스 이중화/서버 클러스터링

데이터베이스 이중화
- 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것
- 하나 이상의 데이터베이스가 항상 같은 상태를 유지
- 데이터베이스가 문제가 생기면 즉시 해결 가능
- 사용자가 작업을 수행하면 이중화 시스템에 연결된 다른 데이터베이스도 동일하게 적용
- 애플리케이션을 여러 개의 데이터베이스로 분산시켜 처리해 데이터베이스의 부하를 감소

데이터베이스 이중화의 분류
- 내용 전달 방식에 따른 분류
ㄱ. Eager 기법 : 트랜잭션 수행 중 데이터 변경 발생 시 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용
ㄴ. Lazy 기법 : 트랜잭션 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달하여 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주

데이터베이스 이중화 구성 방법
ㄱ. 활동-대기 방법
 - 한 DB가 서비스 시 다른 DB는 대기
 - 활성 DB에 장애 발생 시 대기 중이었던 DB가 모든 서비스를 대신 수행
 - 구성 방법 및 관리가 쉬워 많은 기업에서 사용
ㄴ. 활동-활동 방법
- 두 개의 DB가 서로 다른 서비스를 제공
- 한쪽 DB에 장애 발생 시 다른 DB가 서비스를 제공
- 두 DB가 모두 처리를 해 처리율이 높지만 구성 방법 및 설정이 복잡

클러스터링
- 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
- 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공
스토리지(Storage) : 데이터를 저장하는 저장소
고가용성 : 시스템을 오랜 시간 동안 계속해서 정상적으로 운영이 가능한 성질
- 병렬 처리 클러스터링 : 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리
- 고가용성 클러스터링 : 하나의 서버에 장애가 발생 시 다른 서버가 받아서 처리하여 서비스 중단을 방지하는 방식

데이터베이스 보안 / 암호화

데이터베이스 보안
데이터베이스의 일부분 또는 전체에 권한이 없는 사용자가 액세스 하는 것을 금지하기 위해 사용되는 기술

암호화 / 복호화
암호화는 데이터를 보낼 때 송신자가 지정한 수신자 외는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것, 복
호화는 암호문을 원래의 평문으로 바꾸는 것

개인키 / 공개키 암호 방식
ㄱ. 암호화 방식의 키와 복호화 방식의 키가 같을 때
- 개인키 / 비밀키 / 대칭키 암호 방식
- 종류 : 전위 기법, 대수 기법, 합성 기법(DES)
ㄴ. 암호화 방식의 키와 복호화 방식의 키가 다를 때
- 공개키 / 비대칭키 - RSA 기법

78. 데이터베이스 보안 – 접근통제

접근통제
데이터가 저장된 객체와 사용하려는 주체 사이의 정보 흐름을 제한
- 데이터에 대해 통제를 함으로써 자원의 불법적인 접근 및 파괴를 예방

ㄱ. 임의 접근통제(Discretionary Access Control)
: 데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여
- 통제 권한이 주체에 있어 접근통제 권한을 주체가 지정하고 제어
- 객체를 생성한 사용자가 객체에 대한 모든 권한을 부여받고 다른 사용자에게 허가 가능
- SQL 명령어로는 GRANT, REVOKE가 있음

ㄴ. 강제 접근통제(Mandatory Access Control)
: 주체와 객체의 등급을 비교하여 접근 권한을 부여
- 제 3자가 접근통제 권한 지정
- 객체별로 보안 등급을 부여할 수 있으며 사용자별로 인가 등급을 부여할 수 있음
- 주체의 보안 등급이 자신의 보안등급보다 높으면 읽기, 수정, 등록이 모두 불가하고 동등하면 읽기, 수정, 등록이 모두 
가능하며 낮으면 읽기만 가능

접근통제 정책
어떤 주체(Who)가 언제(When) 어디서(Where) 어떤 객체(What)에게 어떤 행위(How)에 대한 허용 여부를 정의하는 것

ㄱ. 신분 기반 정책
주체나 그룹의 신분에 근거하여 객체의 접근을 제한
ㄴ. 규칙 기반 정책
: 주체가 갖는 권한에 근거하여 객체의 접근을 제한
ㄷ. 역할 기반 정책
: 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 
접근을 제한

접근통제 매커니즘
정의된 접근통제 정책을 구현하는 기술적인 방법
- 접근통제 목록 : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지 기록한 목록
- 능력 리스트 : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록
- 보안 등급 : 주체나 객체에 부여된 보안 속성의 집합
- 패스워드 : 주체가 자신임을 증명할 때 사용하는 인증 방법
- 암호화

접근통제 보안 모델
보안 정책을 구현하기 위한 정형화된 모델

ㄱ. 기밀성 모델
군사적인 목적으로 개발된 최초의 수학적 모델로 기밀성 보장이 최우선

ㄴ. 무결성 모델
기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
- 데이터 일관성 유지에 중점을 두어 개발

ㄷ. 접근통제 모델
접근통제 매커니즘을 보안 모델로 발전시킨 것
접근통제 모델 : 임의적인 접근 통제를 관리하기 위한 모델로 행은 주체 열은 객체를 의미
- R : 읽기 권한
- W : 쓰기 권한
- ALL : 모든 권한

접근통제 조건
접근통제 매커니즘의 취약점을 보완하기 위해 접근 통제 정책에 부가하여 적용할 수 있는 조건
ㄱ. 값 종속 통제 : 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우
ㄴ. 다중 사용자 통제 : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우
ㄷ. 콘텍스트 기반 통제 : 특정 시간, 네트워크 주소, 접근 경로, 인증 경로 등에 근거하여 접근을 제어하는 방식

감사 추적
- 사용자나 애플리케이션의 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능
- 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용

데이터베이스 백업

데이터베이스 백업
전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업

데이터베이스 장애 유형
ㄱ. 사용자 실수 : 사용자의 실수로 인한 오류
ㄴ. 미디어 장애 : 하드웨어 장애나 데이터가 파손된 경우
ㄷ. 구문 장애 : 프로그램 오류나 사용 공간의 부족으로 발생하는 장애
ㄹ. 사용자 프로세스 장애 : 프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 장애
ㅁ. 인스턴스 장애 : 하드웨어 장애, 정전, 시스템 파일 파손 등 비정상적 요인으로 메모리나 데이터베이스 서버의 프로세스가 중단된 경우

로그 파일
데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 파일
- 로그 파일을 기반으로 과거 상태로 복귀(UNDO)시키거나 현재 상태로 재생(REDO)시켜 데이터베이스 상태를 일관성 있게 유지

데이터베이스 복구 알고리즘
- 동기적/비동기적 갱신에 따라 분류
- NO-UNDO/REDO : 비동기적으로 갱신한 경우
- UNDO/NO-REDO : 동기적으로 갱신한 경우
- UNDO/REDO : 동기/비동기적으로 갱신한 경우
- NO-UNDO/NO-REDO : 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우

백업 종류
ㄱ. 물리 백업 : 데이터베이스 파일을 백업하는 방법
ㄴ. 논리 백업 : 데이터베이스 내의 논리적 객체들을 백업하는 방법

스토리지(Storage)

스토리지
: 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술

DAS(Direct Attached Storage)
서버와 저장장치를 전용 케이블로 직접 연결하는 방식
- 서버에서 저장장치를 관리
- 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움
- 다른 서버에서 스토리지에 접근하여 사용 불가

NAS(Network Attached Storage)
: 서버와 저장장치를 네트워크를 통해 연결하는 방식
- 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리
- DAS에 비해 확장성 및 유연성이 좋음
- 서버들이 자유롭게 스토리지에 접근하여 파일 공유

SAN(Storage Area Network)
: DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식
- 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성
- 파이버 채널(FC) 스위치를 이용하여 네트워크를 구성
- 파이버 채널 : 장치 간 데이터 전송 속도를 기가바이트로 높이기 위한 네트워크 기술
- 서버나 저장장치를 광케이블로 연결하므로 처리 속도가 빠름
- 서버들이 저장장치 및 파일을 자유롭게 공유


81. 논리 데이터 모델의 물리 데이터 모델 변환

테이블 
데이터를 저장하는 데이터베이스의 가장 기본적인 오브젝트

엔티티를 테이블로 변환
논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환
- 테이블과 엔티티 명칭은 동일하게 하는 것을 권고
- 테이블은 소스코드 가독성을 위해 영문명을 사용
- 표준화된 용어 사용 지향
- 변환 규칙
논리적 설계 -> 물리적 설계
엔티티 -> 테이블
속성 -> 컬럼
주 식별자 -> 기본키
외부 식별자 -> 외래키
관계 -> 관계
 
슈퍼타입/서브타입을 테이블로 변환
- 슈퍼타입과 서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 테이블로 변환

SQL의 개념

SQL(Structured Query Language)이란?
구조화된 질의 언어, 국제 표준 데이터베이스 언어이며 많은 관계형 데이터베이스(RDB)를 지원하는 언어로 채택

SQL의 분류
ㄱ. DDL(Data Define Language, 데이터 정의어)
: 스키마, 도메인, 테이블, 뷰, 인덱스를 정의, 변경, 삭제할 때 사용하는 언어
a. CREATE : 스키마, 도메인, 테이블, 뷰, 인덱스를 정의 
b. ALTER : 테이블에 대한 정의를 변경
c. DROP : 스키마, 도메인, 테이블, 뷰, 인덱스를 삭제
d. TRUNCATE : 테이블을 초기화

ㄴ. DML(Data Manipulation Language, 데이터 조작어)
사용자가 저장된 데이터를 실질적으로 처리하는 데 사용
a. SELECT : 테이블에서 조건에 맞는 튜플 검색
b. INSERT : 테이블에 새로운 튜플 삽입
c. DELETE : 테이블에서 조건에 맞는 튜플 삭제
d. UPDATE : 테이블에서 조건에 맞는 튜플의 내용 변경

ㄷ. DCL(Data Control Language, 데이터 제어어)
데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용하는 언어
a. COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고 데이터베이스 조작 작업이 정상적으로 완료되었음을 알려줌
b. ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구
c. GRANT : 데이터베이스 사용자에게 사용 권한을 부여
d. REVOKE : 특정 DB사용자에게 권한 박탈, 회수

프로시저와 트리거

프로시저
절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어이며 호출을 통해 실행되어 미리 저장해 놓은 SQL 
작업을 수행, 여러 프로그램에서 호출하여 사용 가능하고, 시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용됨

ㄱ. 프로시저 구성
- DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부 (필수)
- BEGIN / END : 프로시저의 시작과 종료를 의미 (필수)
- CONTROL : 조건문 또는 반복문이 삽입, 순차적 처리
- SQL : DML, DCL이 삽입돼, 조회, 추가, 수정, 삭제 작업을 수행
- EXCEPTION : 구문 실행 중 예외 발생 시 처리 방법 정의
- TRANSACTION : 작업들을 DB에 적용할지 취소할지 결정하는 처리부

ㄴ. 프로시저 생성과 실행, 제거
표기 형식 
: CREATE PROCEDURE 프로시저명(파라미터)
BEGIN
BODY;
END; 
- CREATE와 PROCEDURE 사이에 OR REPLACE 예약어 사용 시 동일한 프로시저 이름이 존재할 경우, 기존의 프로시저
를 대체함
- 파라미터는 IN, OUT, INOUT, 매개변수명, 자료형이 올 수 
있음. 값을 전달하거나 반환할 때 IN과 OUT, INOUT을 사용함 - 프로시저의 BODY는 BEGIN과 END 사이의 코드 작성 부분이며 하나 이상의 SQL 문이 있어야 한다.
- 프로시저 실행을 위해 EXECUTE, CALL, EXEC로 사용할 수 있음 ex) EXEC 프로시저명; - 제거를 위해서는 DROP PROCEDURE를 사용함

트리거
: DB 시스템에서 삽입, 갱신, 삭제 등 이벤트가 발생할 때마다 자동 수행되는 절차형 SQL로 무결성 유지, 로그 메시지 
출력 등의 목적으로 사용함
-구문에는 DCL을 사용할 수 없고 DCL이 포함된 프로시저나 함수 호출도 불가능

트리거 구성
- DECLARE : 프로시저와 같음
- EVENT : 실행되는 조건 명시
- BEGIN / END : 프로시저와 같음
- CONTROL : 프로시저와 같음
- SQL : 프로시저와 같으나 DCL은 삽입될 수 없음
- EXCEPTION : 프로시저와 같음

트리거 생성
표기 형식 
: CREATE TRIGGER 트리거명 (실행 시기)(옵션) ON 테이블명
REFERENCING (NEW or OLD) AS 테이블명
FOR EACH ROW
BEGIN
BODY;
END; 
- OR REPLACE는 프로시저와 동일하고, 실행 시기는 이벤트가 발생하기 전에 실행하는지 후에 실행하는지에 따라 AFTER와 BEFORE를 사용, 그 뒤에 실행되게 할 작업의 종류를 지정하는 옵션에는 INSERT, DELETE, UPDATE가 있음
- 추가되거나 수정에 참여할 테이블은 NEW, 수정되거나 삭제 전 대상이 되는 테이블은 OLD로 사용한다.
- FOR EACH ROW 는 각 튜플마다 트리거를 적용한다는 의미이며 BODY 부분은 프로시저와 같다. - 제거시 DROP TRIGGER 명령어 사용

공통점과 차이점
- 데이터베이스에 저장하며 절차형 SQL인 것과 구성 시 DECLARE, BEGIN, END를 필수로 가져야 하는 점은 같음
그러나 목적이 다르고 트리거는 데이터 제어어를 사용할 수 없다. EVENT로 자동 수행하는 부분 등, 상세한 부분의 차이
를 알아두어야 한다.

사용자 정의 함수

사용자 정의 함수
프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하여 종료 시 처리 결과를 단일 값으로 반환하는 
절차형 SQL 
- 데이터베이스에 저장되어 DML문의 호출에 의해 실행
- 예약어 RETURN을 통해 값이 반환되기 때문에 출력 파라미터가 없음
- 테이블 조작은 할 수 없고 SELECT를 통해 검색만 할 수 있음
- 프로시저를 호출하여 사용할 수 없음
- 프로시저의 구성과 유사함
표기 형식
CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
[지역변수 선언]
BEGIN
 사용자 정의 함수 BODY;
 RETURN 반환;
END;

DBMS 접속 기술

DBMS 접속 기술
사용자가 데이터를 접속하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것

DBMS 접속 기술
: DBMS에 접근하기 위해 사용하는 API 또는 프레임워크를 의미

ㄱ. JDBC(Java DataBase Connectivity)
- 썬 마이크로시스템에서 출시(java언어)
- Java SE에 포함되어 있고 JDBC 클래스는 java.sql, javax.sql에 포함
- 접속하려는 DBMS에 대한 드라이버 필요
ㄴ. ODBC(Open DataBase Connectivity)
- 개발 언어와 상관없음
- 마이크로소프트에서 출시
- MS-Access, DBase, DB2, Excel, Text 등 다양한 데이터베이스에 접근 가능
ㄷ. MyBatis
- JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈소스 접속 프레임워크
- SQL 문장을 분리하여 XML 파일을 만들고 Mapping을 통해 SQL을 실행
- SQL을 거의 그대로 사용할 수 있어 국내 환경에 적합

동적 SQL
: 개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처
리하는 것

데이터 전환(?)

SQL 테스트

SQL 테스트
SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정
- 단문 SQL은 코드를 직접 실행한 후 결과를 확인
- 절차형 SQL은 테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인
- 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고 결과를 통해 최종 확인

단문 SQL 테스트
- DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 직접 실행하여 테스트


절차형 SQL 테스트
프로시저, 사용자 정의 함수, 트리거 등의 절차형 SQL은 디버깅을 통해 기능의 적합성 여부 검증, 실행을 통해 결과를 
확인하는 테스트를 수행

ORM
ORM(Object-Relational Mapping)
객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술
- 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터 연결
- 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이
- SQL 코드를 직접 사용하지 않기 때문에 직관적이고 간단하게 데이터 조작 가능

ORM 프레임워크
: ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능들을 제공하는 소프트웨어

ORM의 한계
- 프레임워크가 자동으로 작성하기 때문에 의도대로 작성되었는지 확인할 필요가 있음
- 객체지향적 사용을 고려, 설계한 데이터베이스가 아닌 경우 프로젝트가 크고 복잡할수록 ORM 기술을 적용하기 어려움
- 기존의 기업들은 ORM 고려하지 않은 데이터베이스를 사용하고 있어 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요

쿼리 성능 최적화

쿼리 성능 최적화
: 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화
- 최적화 전 APM을 사용하여 최적화할 쿼리 선정
- APM(Application Performance Management/Monitoring) 
: 애플리케이션의 성능 관리를 위해 다양한 모니터링 기능을 제공하는 도구

옵티마이저(Optimizer)란?
SQL 개발자가 SQL을 작성하여 실행할 때, 옵티마이저는 SQL을 어떻게 실행할 것인지를 계획하게 된다
SQL 실행 계획(Execution Plan)을 수립하고 SQL을 실행할시옵티마이저는 SQL의 실행 계획을 수립하고 SQL을 실행하는 
데이터베이스 관리 시스템의 소프트웨어이다.
동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라서 성능이 달라지기에, SQL 성능에 옵티마이저는 아주 중요한 역할을 한다

실행 계획
: DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미

쿼리 성능 최적화
실행 계획에 표시된 연산 순서, 조인 방식, 테이블 조회 방법 등을 참고하여 SQL문이 더 빠르고 효율적으로 작동하도록  코드와 인덱스를 재구성

ㄱ. SQL 코드 재구성
a. WHERE 절을 추가하여 일부 레코드만 조회
b. WHERE 절에 연산자 사용 자제
c. 특정 데이터 확인 시 IN보다 EXISTS 사용
d. 힌트를 활용하여 실행 계획의 액세스 경로 및 조인 순서 변경

ㄴ. 인덱스 재구성
a. SQL 코드에서 조회되는 속성과 조건들을 고려하여 인덱스 구성
b. 인덱스를 추가하거나 기존 인덱스의 열 순서 변경
c. 단일 인덱스로 쓰기나 수정 없이 읽기로만 사용되는 경우 IOT(Index-Organized Table)로 구성
```