# 2022.09.30
#etc/2022.09.30

---

```
# OSI 7계층, TCP/IP 4계층

OSI 7계층

**국제통신표준** 규약으로 통신에서 일어나는 과정을 **7가지로 단계**로 나눈 것입니다. 이렇게 나눈 이유는 흐름을 **한눈에 파악하기 쉽고** 각 계층은 **독립적**으로 존재함으로 써 **문제가 발생할 시 어디서 문제가 났는지** 파악하기 좋습니다.

1계층은 물리 계층으로 데이터가 **어떤 데이턴지 에러가 있는지 신경 쓰지 않고** **그냥 데이터를 전송하는 역활**을 합니다. 전송 단위는 **비트**이며 대표적인 장비로 **케이블, 허브, 리피터**가 있습니다.

2계층은 데이터링크 계층

2계층은 데이터링크 계층으로 물리계층에서 송수신되는 정보의 **오류와 흐름을 관리하여 좀더 안전하게 전달할 수 있는 역활**을 합니다. 전송 단위는 **프레임**이며 대표적인 장비로는 **브릿지, 스위치**가 있습니다.

브릿지와 스위치는 2이상의 링크 네트워크를 결합하여 LAN을 확장 구성하는 장비입니다.

브릿지는 수개의 포트를 연결하며, 한번에 하나의 프레임만 전달합니다. Store and Forward 방식을 사용하는데 Store and Forward는 데이터 전송할 때 프레임 전체를 내부 버퍼에 저장했다가 에러검출과 같은  처리를 완전히 한 후에 목적지로 보내는 방식입니다.

스위치는 브릿지보다 훨씬 많은 포트를 연결할  수 있으며 한번에 여러 프레임을 병렬로 전달할 수 있어 빠릅니다. 스위치는 Store and Forward 방식뿐 아니라 Cut Through 방식도 사용하는데 이 방법은 프레임 전체가 수신 되기전에 헤더의 목적지만 보고 판단해 즉시 전송하는 기술입니다. 속도는 빠르지만 에러복구 능력이 약합니다.

3계층 네트워크 계층

3계층은 네트워크 계층으로 가장 중요한 기능으로는 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 라우팅 기능입니다. 경로를 선택하고 패킷을 전달해주는 것이 이 계층의 역활입니다. 대표적인 장비로는 라우터가 있습니다.

4계층 전송 계층

4계층은 전송 계층으로 **양쪽의 프로세스들이 데이터를 주고 받을 수 있게 해주며, 포트를 열여서 응용 프로그램들이 전송**을 할 수 있게 해줍니다. 대표적으로 **TCP, UD**P 프로토콜이 있으며 통신 단위는 TCP 같은 경우 **Segemen**t, UDP는 **Datagram**입니다.

TCP는 신뢰성 있는 연결 지향 프로토콜으로 패킷 손실, 중복, 순서 바뀜이 없습니다.

UDP는 신뢰성 없는 비연결성 프로토콜이지만, 속도가 빨라서 빠른 요청이 필요한 실시간에 적합합니다.

5계층 세션 계층

5계층은 **세션 계층**으로 **양쪽 프로세스가 half duplex나 full duplex 처럼 통신을 관리**하기 위한 방법을 제공합니다. 이 계층은 **TCP/IP 세션을 만들고 없애는 역활**을 하며 통신 데이터는 **data**입니다.

half duplex는 sender와 receiver가 한번에 **하나씩만 통신**이 가능한 방법입니다.

full duplex sender와 recevier가 **동시에 정보를 전송하고 수신**이 가능합니다.

6계층 표현 계층

6계층은 표현 계층으로 **인코딩이나 암호화를 담당**하여 **애플리케이션 계층이 다양한 타입을 다루는 부담을 줄여줍니다.** 통신 단위는 5계층과 같이 **data**입니다.

7계층 애플리케이션 계층

7계층은 애플리케이션 계층으로 **응용 프로세스와 관계하여 일반적인 응용 서비스를 수행**합니다. 즉, 우리가 사용하는 사용자 인터페이스를 제공하는 프로그램을 말합니다, 대표적으로 **HTTP, FTP** 프로토콜이 이 계층에 속하며 통신 단위는 **data**입니다.

TCP/IP 4계층

**OSI 7 Laye**r는 **장비 개발이나 통신 자체를 어떻게 표준으로 잡을지 사용**하는 반면에 **실제적인 통신 자체는 TCP/IP 프로토콜**을 사용합니다.

1 계층은 **네트워크 액세스 계층**으로 **물리계층과 데이터링크** 계층에 해당하고 **하드웨어와 관련된 요소를 지원**해주는 계층입니다.

2 계층은 **인터넷 계층**으로 **OSI의 네트워크 계층에 해당하며 라우팅 역활**을 해줍니다.

3 계층은 **전송 계층**은 **OSI와 같이 전송 계층에 해당하며 양쪽의 프로세스들이 데이터를 전송**할 수 있게 해줍니다.

4계층은 **애플리케이션 계층**으로 **응용 프로세스와 관계하여 응용 서비스를 수행**할 수 있게 해줍니다.

TCP/IP 4계층이 OSI 7계층보다 **먼저 만들어 졌기** 때문에 두 모델은 **정확하게 일치하지 않습니**다. 두 모델 모두 **계층형이라는 공통점**이 있지만 TCP/IP는 인터넷 개발 이후 **계속 표준화되어 신뢰성이 우수**한 반면 OSI 7은 **실제적으로 구현되는 예가 잘 없어 신뢰가 저하**되어있습니다.
```

```
# TCP vs UDP

TCP는 연결형, 신뢰성 전송 프로토콜입니다. 연결 지향적 서비스를 제공하기위해 데이터를 전송하기 전에 3 hand shaking을 하여 두 호스트간에 논리적 연결을 설립합니다. 그리고 신뢰성 있는 서비스를 제공하기 위해 오류 제어, 흐름 제어, 혼잡 제어 등을 실행합니다. 이렇게 연결성과 신뢰성을 제공하기 위해 header가 더 크고 느리다는 단점이 있습니다.

UDP는 비연결형 프로토콜로 3way handshake 과정이 없습니다. 또한 비신뢰성 프로토콜로 흐름제어, 오류제어, 혼잡 제어를 제공하지 않습니다. 이런 단순성 때문에 적은양의 오버헤드를 갖고 수신 여부를 확인하지 않기 때문에 속도가 빠릅니다.

TCP는 신뢰성이 중요한 통신인 HTTP,  파일전송에 쓰이고 UDP는 실시간성이 중요한 통신인 동영상 스트리밍 같은 곳에 주로 사용됩니다.
```

```
# 3way handshaking, 4 way handshaking

3 way handshaking(연결 설정)

3way handshkaing은 **tcp 연결과정으로** 정**확한 전송을 위해 상대방과 사전에 세션을 수립**하는 과정입니다.

1. Client에서 Server로 접속을 요청하는 **SYN** 메시지를 보냅니다. 보내고 나면 클라이언트 **SYN_SENT** 상태, Server는 **wait for client**상태입니다.
2. Server는 SYN요청을 받고 Client에게 요청을 수락한다는 **ACK와 SYN flag**가 설정된 패킷을 발송하고 클라이언트가 다시 ACK으로 응답하기를 기다립니다. 이 때 서버는 **SYN_RECEIVED** 상태가 됩니다.
3. 클라이언트가 서버에서 **ACK과 SYN 메시지를 받고** 서버에게 **ACK 메시지를 보내게 되면** 서로 **ESTABLISEHD** 상태가 되어 **연결이 이루어지고 서로 데이터를 교환**할 수 있게 됩니다.

4 way handshaking(해제 설정)

3way handshaking으로 연결했다면 이제 4 way handshaking으로 **연결을 해제** 해주게 됩니다.

1. 클라이언트가 **연결을 종료하겠다는 FIN 메시지를 전송**합니다. 이 때 클라이언트 **FIN-WAIT** 상태가 됩니다.
2. 서버에서 **FIN 메시지를 받으면 일단 확인메시지 ACK**를 보내고 자**신의 통신이 끝날때까지 기다리는데 이 상태가 CLOSE-WAIT상태**입니다.
3. 서버에서 연결을 **종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN메시지를 전달**합니다. 이때 서버의 상태는 **LAST-ACK** 상태입니다.
4. 클라이언트는 **해지준비가 되었다는 FIN를 받으면 수락하는 ACK 메시지를 보내고** 상태가 FIN-WAIT에서 **TIME WAIT**로 변경됩니다. 여기서 ACK 메시지를 보내고 바로 종료하지 않고 **기다리는 이유**는 서버에서 **마지막으로 FIN 메시지를 전송하기전에 전송한 패킷이 재전송 같은 이유로 FIN보다 늦게 도착하는 경우**에는 닫은 상태면 **패킷이 손실**되기 때문에 이런 현상을 막기 위해 **일정한 시간이 지나면 세션을 만료해 연결을 종료**시킵니다. 이 때 **TIME-WAIT에서 CLOSE 상태**가 됩니다.
```

```
# 웹 동작 방식

1. 유저가 브라우저에 **URL을 입력**하면 **Http request message가 생성**됩니다.
2. **DNS서버**에서 **도메인에 맞는 IP를 반환**받습니다.
3. Http request message에 **IP 헤더를 붙여서 TCP/IP 패킷을 생성**하고 전송 요청을 합니다.
4. 해당 패킷은 **전기신호로 랜선을 통해 네트워크로 전송되고, 목적지 서버에 도착**하게 됩니다.
5. 서버는 HTTP 요청 메시지에 대한 응답 데이터를 가지고 **HTTP 응답 메시지를 생성**합니다.
6. HTTP 응답 메시지를 전달 받은 방식 **그대로 client IP로 전송** 합니다.
7. Http 응답 메시지에 담긴 데이터를 기반으로 **웹브라우저에서 HTML을 렌더링**해 모니터에 보이게 됩니다.
```

```
# HTTP, HTTPS

HTTP

HTTP는 **서버/클라이언트 모델**에 따라 **데이터를 주고받기 위한 프로토콜**입니다. HTTP는 **애플리케이션 레벨의 프로토콜**로 **TCP/IP** 위에서 작동합니다. HTTP의 주요 특징으로는 서버가 요청에 응답을 마치면 연결을 끊는 **Connectionless**한 성질과 이전 통신에 대한 정보를 저장하지 않는 **stateless**한 특징을 가지고 있습니다. 

HTTPS

HTTP는 **평문 데이터를 전송하는 프로토콜**이기 때문에 **비밀번호나, 주민번호 같은 개인정보**를 주고 받으면 **제3자에 의해서 조회될 수 있기 때문에 위험**합니다. 이런 문제를 해결하기 위해 HTTP에 **암호화가 추가된 프로토콜이 HTTPS**입니다. 

HTTPS는 **대칭키 암호화**와 **비대칭키 암호화**를 둘 다 사용합니다. 키를 두개 사용하는 **비대칭키 암/복호화는 비용이 매우 크기** 때문에 **서버와 클라이언트가 교환하는 메시지를 모두 비대칭키로 하면 오버헤드가 발생할 수** 있기 때문에 **이때는 대칭키 암호화를 사용**하고 **이 대칭키를 최초에 1번 교환하기 위해서 비대칭키 암호화를 사용**합니다.

그 과정을 한 번 보면

1. 클라이언트가 서버에 최초 연결 시도를 하면
2. 서버는 공개키를 브라우저에게 넘겨줍니다.
3. 브라우저는 세션키를 발급하고 브라우저는 인증서의 유효성을 검사해 공개키를 얻습니다.
4. 브라우저는 세션키를 보관하고 공개키로 이 세션키를 암호화하여 서버로 전송합니다.
5. 서버는 개인키로 세션키를 복호화하여 세션키를 얻습니다.
6. 이제 클라이언트와 서버는 서로 세션키라는 대칭키를 가지고 있기 때문에 데이터를 교환할 때 이 대칭키를 이용하여 암/복호화합니다.
```